[
	uuid(6f15af3b-0784-4fe4-a512-02e9006cf660),
	version(1.0),
	pointer_default(ptr)
]
interface PrtDistributed {


/** Declare all the typedefs **/
	/***********************************************************************************************/
	//		Types 
	/***********************************************************************************************/
	/** PRT uses these definitions for boolean values */
	typedef enum PRT_BOOLEAN
	{
		PRT_FALSE = 0,   /**< 0 means false */
		PRT_TRUE = 1    /**< 1 means true  */
	} PRT_BOOLEAN;

	typedef enum _PRT_TYPE_KIND PRT_TYPE_KIND;

	//typedef struct _PRT_TYPE PRT_TYPE;

	typedef struct _PRT_MAPTYPE PRT_MAPTYPE;

	typedef struct _PRT_NMDTUPTYPE PRT_NMDTUPTYPE;

	typedef struct _PRT_SEQTYPE PRT_SEQTYPE;

	typedef struct _PRT_TUPTYPE PRT_TUPTYPE;

	typedef struct _PRT_FORGNTYPE PRT_FORGNTYPE;

	/** Declare all the platform dependent types */
	/** PRT_UINT8 is always an 8-bit unsigned integer. */
	typedef unsigned small  PRT_UINT8;
	/** PRT_UINT16 is always a 16-bit unsigned integer. */
	typedef unsigned short PRT_UINT16;
	/** PRT_UINT32 is always a 32-bit unsigned integer. */
	typedef unsigned long PRT_UINT32;
	/** PRT_UINT64 is always a 64-bit unsigned integer. */
	typedef unsigned long long PRT_UINT64;

	/** PRT_INT8 is always an 8-bit signed integer. */
	typedef signed small  PRT_INT8;
	/** PRT_INT16 is always a 16-bit signed integer. */
	typedef signed short PRT_INT16;
	/** PRT_INT32 is always a 32-bit signed integer. */
	typedef signed long PRT_INT32;
	/** PRT_INT64 is always a 64-bit signed integer. */
	typedef signed long long PRT_INT64;

	/** PRT_CHAR is always an ASCII character. */
	typedef char PRT_CHAR;
	/** PRT_STRING is always an array of ASCII characters. */
	typedef char * PRT_STRING;
	/** PRT_CSTRING is always a constant array of ASCII characters. */
	typedef char const * PRT_CSTRING;

	/** These are the kinds of types in the P type system. */
	enum _PRT_TYPE_KIND
	{
		PRT_KIND_ANY = 0,   /**< The kind of the `any` type        */
		PRT_KIND_BOOL = 1,   /**< The kind of the `bool` type       */
		PRT_KIND_EVENT = 2,   /**< The kind of the `event` type      */
		PRT_KIND_FORGN = 3,   /**< The kind of all foreign types     */
		PRT_KIND_MACHINE = 4,   /**< The kind of the `MACHINE` type         */
		PRT_KIND_INT = 5,   /**< The kind of the `int` type        */
		PRT_KIND_MAP = 6,   /**< The kind of all map types         */
		PRT_KIND_MODEL = 7,   /**< The kind of the `MODEL` type        */
		PRT_KIND_NMDTUP = 8,   /**< The kind of all named tuple types */
		PRT_KIND_NULL = 9,	   /**< The kind of the `NULL` type		  */
		PRT_KIND_SEQ = 10,   /**< The kind of all sequence types    */
		PRT_KIND_TUPLE = 11,  /**< The kind of all tuple types       */
		PRT_TYPE_KIND_COUNT = 12,   /**< The number of type kinds        */
		PRT_TYPE_KIND_CANARY = 0xFF /**< A freed type will have this as its kind */
	};


	/** A type is expressed as a discriminicated union of all types */
	typedef union switch (PRT_TYPE_KIND typeKind) typeUnion{
	case PRT_KIND_ANY: PRT_UINT32 dummy_1;
	case PRT_KIND_BOOL: PRT_UINT32 dummy_2;
	case PRT_KIND_EVENT: PRT_UINT32 dummy_3;
	case PRT_KIND_FORGN: PRT_FORGNTYPE* forgn;
	case PRT_KIND_MACHINE: PRT_UINT32 dummy_4;
	case PRT_KIND_INT: PRT_UINT32 dummy_5;
	case PRT_KIND_MAP: PRT_MAPTYPE* map;
	case PRT_KIND_MODEL: PRT_UINT32 dummy_6;
	case PRT_KIND_NMDTUP: PRT_NMDTUPTYPE* nmTuple;
	case PRT_KIND_NULL: PRT_UINT32 dummy_7;
	case PRT_KIND_SEQ: PRT_SEQTYPE* seq;
	case PRT_KIND_TUPLE: PRT_TUPTYPE* tuple;
	} PRT_TYPE;

	/** The layout for map types. */
	struct _PRT_MAPTYPE
	{
		PRT_TYPE      domType;   /**< The domain type of the map type */
		PRT_TYPE      codType;   /**< The codomain type of the map type */
	};

	/** The layout for named tuple types. */
	struct _PRT_NMDTUPTYPE
	{
		PRT_UINT32    arity;         /**< Arity of tuple type; arity > 0 */
		PRT_STRING    *fieldNames;   /**< Array of valid field names; length = arity */
		PRT_TYPE      *fieldTypes;   /**< Array of field types; length = arity */
	};

	/** The layout for sequence types. */
	struct _PRT_SEQTYPE
	{
		PRT_TYPE      innerType;  /**< Inner type of the sequence */
	};

	/** The layout for tuple types. */
	struct _PRT_TUPTYPE
	{
		PRT_UINT32    arity;         /**< Arity of tuple type; arity > 0 */
		PRT_TYPE      *fieldTypes;   /**< Array of field types; length = arity */
	};

	/** Structure for representing a standard GUID */
	typedef struct PRT_GUID
	{
		PRT_UINT32 data1;   /**< 0 First data field (32 bits)  */
		PRT_UINT16 data2;   /**< 0 Second data field (16 bits) */
		PRT_UINT16 data3;   /**< 0 Third data field (16 bits)  */
		PRT_UINT64 data4;   /**< 0 Fourth data field (64 bits) */
	} PRT_GUID;


	/** The PRT_FORGN_CLONE function is called whenever a foreign value needs to be cloned.
	*   The cloning semantics depends on the memory management strategy of the client.
	*   @see PRT_PRT_FORGN_FREE
	*/
	typedef void*(*PRT_FORGN_CLONE)(PRT_GUID typeTag, void *frgnVal);

	/** The PRT_FORGN_FREE function is called whenever a foreign value will never be used again.
	*   The semantics of PRT_FORGN_FREE depends on the memory management strategy of the client.
	*   @see PRT_FORGN_CLONE
	*/
	typedef void(*PRT_FORGN_FREE)(PRT_GUID typeTag, void *frgnVal);

	/** The PRT_FORGN_GETHASHCODE function is called to get a hashcode for a foreign value.
	*   The semantics depends of the client's definition of value equality. If two values
	*   are equal, then the function must return the same hashcode.
	*   @see PRT_FORGN_GETHASHCODE
	*/
	typedef PRT_UINT32(*PRT_FORGN_GETHASHCODE)(PRT_GUID typeTag, void *frgnVal);

	/** The PRT_FORGN_ISEQUAL function tests if two values are equal.
	*   Equality semantics is determined by the client. If two values
	*   are equal, then they should also have the same hashcode.
	*   @see PRT_FORGN_GETHASHCODE
	*/
	typedef PRT_BOOLEAN(*PRT_FORGN_ISEQUAL)(
		 PRT_GUID typeTag1,
		 void *frgnVal1,
		 PRT_GUID typeTag2,
		 void *frgnVal2);

	/** The layout for foreign types */
	//TODO : Function pointer not allowed in RPC
	struct _PRT_FORGNTYPE
	{
		PRT_GUID              typeTag;    /**< A non-zero GUID used by the client to tag the foreign types of values */
		#if !defined(IGNORE_FRG)
		PRT_FORGN_CLONE       cloner;     /**< Clones foreign values */
		PRT_FORGN_FREE        freer;      /**< Frees foreign values */
		PRT_FORGN_GETHASHCODE hasher;     /**< Hashes foreign values */
		PRT_FORGN_ISEQUAL     eqTester;   /**< Tests foreign values for equality */
		#endif

	};

	/***********************************************************************************************/
	//		Values
	/***********************************************************************************************/

	//typedef struct _PRT_PRIMVALUE_UNION PRT_PRIMVALUE_UNION;

	typedef struct _PRT_PRIMVALUE PRT_PRIMVALUE;

	typedef struct _PRT_FORGNVALUE PRT_FORGNVALUE;

	typedef struct _PRT_TUPVALUE PRT_TUPVALUE;

	typedef struct _PRT_SEQVALUE PRT_SEQVALUE;

	typedef struct _PRT_MAPVALUE PRT_MAPVALUE;

	typedef struct _PRT_MAPNODE PRT_MAPNODE;

	typedef union switch (PRT_TYPE_KIND discriminator) valueUnion{
	case PRT_KIND_BOOL: PRT_BOOLEAN bl;
	case PRT_KIND_EVENT: PRT_UINT32  ev;
	case PRT_KIND_MACHINE: PRT_UINT32  mach;
	case PRT_KIND_MODEL: PRT_UINT32  model;
	case PRT_KIND_INT: PRT_INT32   nt;
	} PRT_VALUE;

	/** A primitive value is primitive type paired with a primitive value. */
	struct _PRT_PRIMVALUE
	{
		PRT_TYPE type;        /**< Must be a primitive type. */
		PRT_VALUE *value;  /**< A primitive value is of PRT_PRIMVALUE_UNION type. */
	};

	/** A foreign value is foreign type paired with a void *. */
	struct _PRT_FORGNVALUE
	{
		PRT_TYPE type;    /**< Must be a foreign type.         */
		void    *value;   /**< A pointer to the foreign value. */
	};

	/** A tuple value is a (named) tuple represented as an array. */
	struct _PRT_TUPVALUE
	{
		PRT_TYPE   type;     /**< Must be a (named) tuple type. */
		PRT_VALUE *values;   /**< Is an array of tuple args.    */
	};

	/** A sequence value is a sequence represented as a dynamic array. */
	struct _PRT_SEQVALUE
	{
		PRT_TYPE   type;     /**< Must be a sequence type.                */
		PRT_UINT32 size;     /**< The number of elements in the sequence. */
		PRT_UINT32 capacity; /**< The number of elements before resizing  */
		PRT_VALUE *values;   /**< An array of values in the sequence.     */
	};

	/** A map value is represented as a hash-table. */
	struct _PRT_MAPVALUE
	{
		PRT_TYPE     type;       /**< Must be a map type.                     */
		PRT_UINT32   size;       /**< The number of elements in the map.      */
		PRT_UINT32   capNum;     /**< An opaque number related to the number of buckets */
		PRT_MAPNODE *first;    /**< First element inserted into the map. */
		PRT_MAPNODE *last;     /**< Last element inserted into the map. */
		PRT_MAPNODE **buckets; /**< An array of pointers to chained nodes.  */
	};

	/** A key-value node of a map. */
	struct _PRT_MAPNODE
	{
		PRT_VALUE key;     /**< The key of this node. */
		PRT_VALUE value;   /**< The value of this node. */
		PRT_MAPNODE *bucketNext;   /**< The next node in this bucket.         */
		PRT_MAPNODE *insertNext;   /**< The next node in insertion order.     */
		PRT_MAPNODE *insertPrev;   /**< The previous node in insertion order. */
	};

	/***********************************************************************************************/
	//		Functions
	/***********************************************************************************************/
	
	void SendValue1(
		[in] handle_t handleM,
		[in, ptr] PRT_PRIMVALUE* value
		);

	void SendValueMap1(
		[in] handle_t handleM,
		[in, ptr] PRT_MAPVALUE* value
		);

}
