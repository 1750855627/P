[
   modules.P = '"P at ..\Domains\P.4ml"',
   modules.C = '"C at ..\Domains\C.4ml"'
]

transform P2CProgram (in:: P) returns (out:: C)
/*
[
    compiler_ProductivityCheck = "TypeConstant[0]"
]
*/
{
    /*************************************************************/
    /**********         Create Header File             ***********/
    /*************************************************************/
    //// Elements will be output to header file in order of position.
    HOut ::= (pos: Natural, cmp: out.Cmp).

    //// Concat elements in order.
	HConcatOut ::= (pos: Integer, cmp: out.Cmp).	
	HConcatOut(-1, NIL).
	HConcatOut(m', cmp) :- 
	ho is HOut(_, nxt), HConcatOut(m, before), m' = toOrdinal(ho, 0, { ho' | ho' is HOut }), cmp = Section(before, nxt), m' = m + 1. 		
		
	out.File("program.h", body) :- HConcatOut(count({ho | ho is HOut}) - 1, cmp), 
									body = PpITE(
									   IFNDEF,
									   Ident("P_PROGRAM_H"),
									   Section(
										   Section(
											  PpDefine(Ident("P_PROGRAM_H"), NIL),
											  Section(
											     PpInclude("PrtWinUser.h", FALSE),
											     PpInclude("PrtExecution.h", FALSE)											  
											  )),
										   cmp),
									   NIL).

    //// Elements will be output to c file in order of position.
    COut ::= (pos: Natural, cmp: out.Cmp).

    //// Concat elements in order.
	CConcatOut ::= (pos: Integer, cmp: out.Cmp).	
	CConcatOut(-1, NIL).
	CConcatOut(m', cmp) :- co is COut(_, nxt), CConcatOut(m, before), m' = toOrdinal(co, 0, { co' | co' is COut }), cmp = Section(before, nxt), m' = m + 1. 		
		
	out.File("program.c", body) :- CConcatOut(count({co | co is COut}) - 1, cmp), 
									body = Section(PpInclude("program.h", FALSE), cmp).
								   
    /*************************************************************/
    /**********     Create C Enums for P Decls         ***********/
    /*************************************************************/
	EventDeclExt ::= EventDecl + { DEFAULT, HALT }.
	DeclId ::= (decl: PDecl + { DEFAULT, HALT, PUSH }, id: Natural, cname: String).
	
	//// (1) EventDecls - Id 0, 1 are reserved for default, hault event, which can appear in transition tables.
	DeclId(DEFAULT, 0, "_P_EVENT_DEFAULT").
	DeclId(HALT, 1, "_P_EVENT_HALT").
	DeclId(d, id, cn) :- d is EventDecl, id = 2 + toOrdinal(d, 0, { d' | d' is EventDecl }), cn = strJoin("P_EVENT_", d.name).
	
	HOut(0, out.EnmDef(NIL, "P_EVENTS", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : EventDeclExt, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_EVENTS_COUNT"), size = 2 + count({d | d is EventDecl}) }).  

	//// (2) Real machine decls - Start at Id 0.
	DeclId(d, id, cn) :- d is MachineDecl, d.kind = REAL, 
	                     id = toOrdinal(d, 0, { d' | d' is MachineDecl, d'.kind = REAL }), cn = strJoin("P_MACHINE_", d.name).
	
	HOut(0, out.EnmDef(NIL, "P_MACHINES", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : MachineDecl, d.kind = REAL, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   DeclId(d, id, _), d : MachineDecl, d.kind = REAL, d.isMain = TRUE, enumMember = Element(IntLit(id, DEC, NIL), "_P_MACHINE_MAIN"); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_MACHINES_COUNT"), size = count({d | d is MachineDecl, d.kind = REAL}) }).  

	//// (3) Model machine decls - Start at Id 0.
	DeclId(d, id, cn) :- d is MachineDecl, d.kind = MODEL, 
	                     id = toOrdinal(d, 0, { d' | d' is MachineDecl, d'.kind = MODEL }), cn = strJoin("P_MODEL_", d.name).
	
	HOut(0, out.EnmDef(NIL, "P_MODELS", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : MachineDecl, d.kind = MODEL, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   DeclId(d, id, _), d : MachineDecl, d.kind = MODEL, d.isMain = TRUE, enumMember = Element(IntLit(id, DEC, NIL), "_P_MACHINE_MAIN"); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_MODELS_COUNT"), size = count({d | d is MachineDecl, d.kind = MODEL}) }).  

	//// (4) VarDecls - Start at Id 0.
	DeclId(d, id, cn) :- d is VarDecl, d.owner.kind = REAL, 
	                     id = toOrdinal(d, 0, { d' | d' is VarDecl, d'.owner = d.owner }), 
						 cn = strJoin("P_VAR_", strJoin(d.owner.name, strJoin("_", d.name))).
	
	HOut(0, out.EnmDef(NIL, enumName, list)) :- 
	   m is MachineDecl,
	   enumName = strJoin("P_VARS_", m.name),
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : VarDecl, d.owner = m, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), strJoin("_P_VARS_", strJoin(m.name, "_COUNT"))), size = count({d | d is VarDecl, d.owner = m}) }).  

	//// (5) (Anon)FunDecls - Start at Id 1. The id 0 is reserved for the PUSH action.
	AnonOrNamedFun ::= FunDecl + AnonFunDecl.

	DeclId(d, id, cn) :- d is FunDecl, d.owner.kind = REAL, 
	                     id = 1 + toOrdinal(d, 0, { d' | d' is AnonOrNamedFun, d'.owner = d.owner }), 
	                     cn = strJoin("P_FUN_", strJoin(d.owner.name, strJoin("_", d.name))).

	DeclId(d, id, cn) :- d is AnonFunDecl, d.owner.kind = REAL, 
	                     id = 1 + toOrdinal(d, 0, { d' | d' is AnonOrNamedFun, d'.owner = d.owner }), 
	                     num = toOrdinal(d, 0, { d' | d' is AnonFunDecl, d'.owner = d.owner }),
						 cn = strJoin("P_FUN_", strJoin(d.owner.name, strJoin("_ANON", toString(num)))).
	
	HOut(0, out.EnmDef(NIL, enumName, list)) :- 
	   m is MachineDecl, m.kind = REAL,
	   enumName = strJoin("P_FUNS_", m.name),
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : AnonOrNamedFun, d.owner = m, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   enumMember = Element(IntLit(0, DEC, NIL), strJoin("_P_FUN_", strJoin(m.name, "_PUSH_OR_IGN")));
									   enumMember = Element(IntLit(size, DEC, NIL), strJoin("_P_FUNS_", strJoin(m.name, "_COUNT"))), size = 1 + count({d | d is AnonOrNamedFun, d.owner = m}) }).  

	//// (7) StateDecls - Start at Id 0. Need to encode qualified names.
	DeclId(d, id, cn) :- d is StateDecl, d.owner.kind = REAL, 
	                     QualName2CStr(d.name, name), 
					     id = toOrdinal(d, 0, { d' | d' is StateDecl, d'.owner = d.owner }), 
						 cn = strJoin("P_STATE_", strJoin(d.owner.name, strJoin("_", name))).
	
	HOut(0, out.EnmDef(NIL, enumName, list)) :- 
	   m is MachineDecl,
	   enumName = strJoin("P_STATES_", m.name),
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : StateDecl, d.owner = m, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), strJoin("_P_STATES_", strJoin(m.name, "_COUNT"))), size = count({d | d is StateDecl, d.owner = m}) }).  

	//// (8) Convert qualified names to C strings
	QualNameSub ::= sub (QualifiedName).
	QualName2CStr ::= (QualifiedName, String).
	QualName2CStr(q, s) :- QualNameSub(q), q = QualifiedName(s, NIL).
	QualName2CStr(q, sj) :- QualNameSub(q), QualName2CStr(q', s'), q = QualifiedName(s, q'), sj = strJoin(s', strJoin("_", s)).

    /*************************************************************/
    /******     Generate C statics for types in program     ******/
    /*************************************************************/
	TypeExprSub ::= sub (TypeExpr).

	//// Always encode NULL and ANY types.
	TypeExprSub(in.BaseType(ANY)).
	TypeExprSub(in.BaseType(NULL)).

	//// Labels a type expression with a number greater than the labels of all its sub-expressions.
	//// TypeId linearizes the dependency order to get a schedule for emitting type expressions.
	TypeId      ::= (id: Natural, type: TypeExpr).
	TypeDepNum  ::= (id: Natural, type: TypeExpr).

	TypeDepNum(0, t) :- TypeExprSub(t), t : in.BaseType.
	TypeDepNum(i, t) :- TypeExprSub(t), t = SeqType(t'), TypeDepNum(j, t'), i = j + 1.  
	TypeDepNum(i, t) :- TypeExprSub(t), t = MapType(t', t''), TypeDepNum(j, t'), TypeDepNum(k, t''),  i = j + k + 1.  
	TypeDepNum(i, t) :- TypeExprSub(t), t = TupType(t', NIL), TypeDepNum(j, t'), i = j + 1.  
	TypeDepNum(i, t) :- TypeExprSub(t), t = TupType(t', t''), TypeDepNum(j, t'), TypeDepNum(k, t''),  i = j + k + 1.  
	TypeDepNum(i, t) :- TypeExprSub(t), t = NmdTupType(NmdTupTypeField(_, t'), NIL), TypeDepNum(j, t'), i = j + 1.  
	TypeDepNum(i, t) :- TypeExprSub(t), t = NmdTupType(NmdTupTypeField(_, t'), t''), TypeDepNum(j, t'), TypeDepNum(k, t''), i = j + k + 1.  
	TypeId(id, t) :- td is TypeDepNum(_, t), id = toOrdinal(td, 0, { td' | td' is TypeDepNum }).

	//// Build type initializers in linearization order.
	//// defs is the definitions that preceed the encoding of this type constant.
	TypeConstant ::= (type: TypeExpr + { NIL }, typeExprId: Integer, defs: out.Section + { NIL }).
	TypeConstant(NIL, -1, NIL).

	//// Base types
	BaseType2Kind ::= ({ NULL, BOOL, INT, EVENT, REAL, FOREIGN, ANY }, String).
	BaseType2Kind(NULL, "PRT_KIND_NULL").
	BaseType2Kind(BOOL, "PRT_KIND_BOOL").
	BaseType2Kind(INT, "PRT_KIND_INT").
	BaseType2Kind(EVENT, "PRT_KIND_EVENT").
	BaseType2Kind(REAL, "PRT_KIND_MACHINE").
	BaseType2Kind(FOREIGN, "PRT_KIND_FORGN").
	BaseType2Kind(ANY, "PRT_KIND_ANY").
	
	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), t = in.BaseType(base), BaseType2Kind(base, kind),
								              defs = out.Section(before, def),
										          def = out.VarDef(NIL, NmdType(NIL, "PRT_TYPE"), typeName, typeStruct),
								              typeName = strJoin("P_GEND_TYPE_", toString(m)),
                              typeStruct = out.Init(Args(Ident(kind), Args(Ident("NULL"), NIL))).						              

	//// Complex type Seq 
	//// (cast to PRT_MAPTYPE * is used to avoid compiler warnings when initializing union)
	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), t = in.SeqType(tinner), TypeConstant(tinner, tinnerid, _),
								              defs = out.Section(Section(before, defSeq), def),
                              defSeq = out.VarDef(
                                     NIL, 
                                     NmdType(NIL, "PRT_SEQTYPE"), 
                                     typeNameSeq, 
                                     Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(tinnerid)))), NIL))),										 
                              def = out.VarDef(
                                     NIL, 
                                     NmdType(NIL, "PRT_TYPE"), 
                                     strJoin("P_GEND_TYPE_", toString(m)), 
                                     typeStruct),
								              typeStruct = out.Init(
										              Args(Ident("PRT_KIND_SEQ"), 
											            Args(Cast(PtrType(NmdType(NIL, "PRT_MAPTYPE")), UnApp(ADDR, Ident(typeNameSeq))), 
											            NIL))),
									            typeNameSeq = strJoin("P_GEND_TYPE_SEQ_", toString(m)). 

	//// Complex type Map 
	TypeConstant(t, m, defs) :- 
	                       TypeId(m, t), TypeConstant(_, m - 1, before), t = in.MapType(tdom, tcod), 
	                       TypeConstant(tdom, domid, _), TypeConstant(tcod, codid, _),
								         defs = out.Section(Section(before, defMap), def),
										     defMap = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_MAPTYPE"), 
														  typeNameMap, 
														  Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(domid)))), 
														       Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(codid)))), 
														       NIL)))),
										      def = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_TYPE"), 
														  strJoin("P_GEND_TYPE_", toString(m)), 
														  typeStruct),
							            typeStruct = out.Init(
										            Args(Ident("PRT_KIND_MAP"), 
											          Args(UnApp(ADDR, Ident(typeNameMap)), 
											          NIL))),														  
										      typeNameMap = strJoin("P_GEND_TYPE_MAP_", toString(m)).
	//// Complex type Tuple 
	Tup2ArrayInit ::= (type: TupType, arr: out.Expr). 
	Tup2ArrayInit(t, init) :- TypeExprSub(t), t = TupType(t', NIL), TypeConstant(t', id', _), init = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), NIL)). 
	Tup2ArrayInit(t, init) :- TypeExprSub(t), t = TupType(t', t''), TypeConstant(t', id', _), Tup2ArrayInit(t'', Init(ts'')), 
	                          init = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), ts'')). 

	TypeConstant(t, m, defs) :- 
	                       TypeId(m, t), TypeConstant(_, m - 1, before), Tup2ArrayInit(t, arrInit), t : in.TupType, 
								         defs = out.Section(Section(before, Section(defTupArr, defTup)), def),
										     defTupArr = out.VarDef(
										           NIL, 
															 ArrType(PtrType(NmdType(NIL, "PRT_TYPE")), NIL), 
															 typeNameTupArr, 
															 arrInit),
										     defTup = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_TUPTYPE"), 
														  typeNameTup, 
														  Init(
														    Args(IntLit(lstLength(#TupType, t), DEC, NIL), 
															  Args(Ident(typeNameTupArr), 
															  NIL)))),
										     def = out.VarDef(
										         NIL, 
													   NmdType(NIL, "PRT_TYPE"), 
													   strJoin("P_GEND_TYPE_", toString(m)), 
													   typeStruct),
										    typeStruct = out.Init(
													  Args(Ident("PRT_KIND_TUPLE"), 
													  Args(Cast(PtrType(NmdType(NIL, "PRT_MAPTYPE")), UnApp(ADDR, Ident(typeNameTup))), 
													  NIL))),
										     typeNameTupArr = strJoin("P_GEND_TYPE_TUP_ARR_", toString(m)),
										     typeNameTup = strJoin("P_GEND_TYPE_TUP_", toString(m)).

	//// Complex type NmdTuple 
	NmdTup2ArrayInit ::= (type: NmdTupType, narr: out.Expr, tarr: out.Expr). 
	NmdTup2ArrayInit(t, narr, tarr) :- TypeExprSub(t), t = NmdTupType(NmdTupTypeField(n', t'), NIL), TypeConstant(t', id', _), 
	                                   tarr = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), NIL)), 
	                                   narr = Init(Args(StringLit(n', NIL), NIL)).
									    
	NmdTup2ArrayInit(t, narr, tarr) :- TypeExprSub(t), t = NmdTupType(NmdTupTypeField(n', t'), t''), TypeConstant(t', id', _), NmdTup2ArrayInit(t'', Init(n''), Init(ts'')), 
	                                   tarr = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), ts'')),
	                                   narr = Init(Args(StringLit(n', NIL), n'')).

	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), NmdTup2ArrayInit(t, narr, tarr), t : in.NmdTupType, 
								     defs = out.Section(before, Section(defNmdTupNArr, Section(defNmdTupTArr, Section(defNmdTup, def)))),
										 defNmdTupNArr = out.VarDef(
										              NIL, 
															    ArrType(NmdType(NIL, "PRT_STRING"), NIL), 
															    typeNameNmdTupNArr, 
															    narr),
										 defNmdTupTArr = out.VarDef(
										              NIL, 
															    ArrType(PtrType(NmdType(NIL, "PRT_TYPE")), NIL), 
															    typeNameNmdTupTArr, 
															    tarr),
										 defNmdTup = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_NMDTUPTYPE"), 
														  typeNameNmdTup, 
														  Init(
														  Args(IntLit(lstLength(#NmdTupType, t), DEC, NIL), 
															Args(Ident(typeNameNmdTupNArr), 
															Args(Ident(typeNameNmdTupTArr), 
															NIL))))),
										 def = out.VarDef(
										         NIL, 
													   NmdType(NIL, "PRT_TYPE"), 
													   strJoin("P_GEND_TYPE_", toString(m)), 
													   typeStatic),
							       typeStatic = out.Init(
										      Args(Ident("PRT_KIND_NMDTUP"), 
											    Args(Cast(PtrType(NmdType(NIL, "PRT_MAPTYPE")), UnApp(ADDR, Ident(typeNameNmdTup))), 
											    NIL))),
										 typeNameNmdTupTArr = strJoin("P_GEND_TYPE_NMDTUP_TARR_", toString(m)),
										 typeNameNmdTupNArr = strJoin("P_GEND_TYPE_NMDTUP_NARR_", toString(m)),
										 typeNameNmdTup = strJoin("P_GEND_TYPE_NMDTUP_", toString(m)).

    COut(0, defs) :- TypeConstant(_, c, defs), defs : out.Section, c = count({ td | td is TypeId}) - 1.
    
    /*************************************************************/
    /******            Generate event decls                 ******/
    /*************************************************************/	
	EvDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	EvDecl2PayloadType ::= (EventDecl, out.Expr).
	//// An EventDecl without a payload type has a null payload type.
	EvDecl2PayloadType(d, e) :- d is EventDecl(_, _, NIL), TypeConstant(in.BaseType(NULL), typeId, _), e = Ident(strJoin("P_GEND_TYPE_", toString(typeId))).
	//// An EventDecl with a payload type refers to one of the statically generated types.
	EvDecl2PayloadType(d, e) :- d is EventDecl(_, _, type), TypeConstant(type, typeId, _), e = Ident(strJoin("P_GEND_TYPE_", toString(typeId))), type : in.TypeExpr.

	EvDecl2EvCard      ::= (EventDecl, out.Expr).
	//// An EventDecl without a queue constraint allows 2^32 - 1 events in a queue.
	EvDecl2EvCard(d, e) :- d is EventDecl(_, NIL, _), e = IntLit(4294967295, DEC, U).
	//// An EventDecl with a payload type refers to one of the statically generated types.
	EvDecl2EvCard(d, e) :- d is EventDecl(_, card, _), e = IntLit(card.bound, DEC, U).

	//// Base case
	EvDeclConcat(c, NIL) :- c = count({d | d is EventDecl}) + 2.

    //// Build event array in reverse order
	EvDeclConcat(m, arr) :- DeclId(d, m, cn), EvDeclConcat(m + 1, after), arr = out.Args(def, after), EvDecl2PayloadType(d, type), EvDecl2EvCard(d, card), 
	                        def = Init(
							   Args(Ident(cn),
							   Args(StringLit(d.name, NIL),
							   Args(card,
							   Args(UnApp(ADDR, type),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

	//// Define the halt event
	EvDeclConcat(1, arr) :- EvDeclConcat(2, after), arr = out.Args(def, after), TypeConstant(in.BaseType(ANY), typeId, _),
	                        def = Init(
							   Args(Ident("_P_EVENT_HALT"),
							   Args(StringLit("halt", NIL),
							   Args(IntLit(4294967295, DEC, U),
							   Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(typeId)))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

	//// Define the default event
	EvDeclConcat(0, arr) :- EvDeclConcat(1, after), arr = out.Args(def, after), TypeConstant(in.BaseType(NULL), typeId, _),
	                        def = Init(
							   Args(Ident("_P_EVENT_DEFAULT"),
							   Args(StringLit("default", NIL),
							   Args(IntLit(0, DEC, U),
							   Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(typeId)))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

    //// Emit the event decl array.
	COut(1, def) :- EvDeclConcat(0, arr), 
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_EVENTDECL"), NIL), 
								  "P_GEND_EVENTS", 
								  Init(arr)).

    /*************************************************************/
    /******            Generate Variable Decl Arrays        ******/
    /*************************************************************/	
	VarDeclConcat ::= (pos: Natural, mach: MachineDecl, arr: out.Args + {NIL}).

	//// Base case
	VarDeclConcat(c, m, NIL) :- m is MachineDecl, m.kind = REAL, c = count({v | v is VarDecl, v.owner = m}).

    //// Build every variable array in reverse order
	VarDeclConcat(m, d.owner, arr) :- 
							DeclId(d, m, cvar), DeclId(d.owner, _, cmach), VarDeclConcat(m + 1, d.owner, after), d : VarDecl, TypeConstant(d.type, typeId, _),							  
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(cvar),
							   Args(Ident(cmach),
							   Args(StringLit(d.name, NIL),
							   Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(typeId)))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

	COut(2, def) :- VarDeclConcat(0, mach, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_VARDECL"), NIL), 
								  strJoin("P_GEND_VARS_", mach.name), 
								  Init(arr)).

    /*************************************************************/
    /******          Generate Transition Decl Arrays        ******/
    /*************************************************************/	
	TransDeclConcat ::= (pos: Natural, context: StateDecl, arr: out.Args + {NIL}).
	TransDeclId     ::= (decl: TransDecl, id: Natural, srcName: String, dstName: String, machName: String).

	//// Transition Id also contains source, destination, and owner machine ids
	TransDeclId(t, id, srcname, dstname, machname) :- 
	                t is TransDecl, 
					t.src.owner.kind = REAL,
					id = toOrdinal(t, 0, { t' | t' is TransDecl, t'.src = t.src }),
					DeclId(t.src, _, srcname), 
					DeclId(t.src.owner, _, machname),
					DeclId(dst, _, dstname), dst is StateDecl, dst.owner = t.src.owner, dst.name = t.dst.

    //// Transition event Id depends on whether the transition is a user event, default, or halt.
    TransDeclEvnt  ::= (decl: TransDecl, evName: String, id: Natural).
	DefaultOrHalt  ::= { DEFAULT, HALT }.
	TransDeclEvnt(t, evname, id) :- t is TransDecl, t.src.owner.kind = REAL, ev is EventDecl, ev.name = t.trig, DeclId(ev, id, evname).
	TransDeclEvnt(t, evname, id) :- t is TransDecl, t.src.owner.kind = REAL, trig = t.trig, trig : DefaultOrHalt, DeclId(trig, id, evname).

	//// Transition action index depends on whether the transition is a push transition or not.
    TransDeclAction  ::= (decl: TransDecl, funName: String).
	TransDeclAction(t, funname) :- t is TransDecl, t.src.owner.kind = REAL, t.action = PUSH, funname = strJoin("_P_FUN_", strJoin(t.src.owner.name, "_PUSH_OR_IGN")). 
	TransDeclAction(t, funname) :- t is TransDecl, t.src.owner.kind = REAL, act = t.action, act : AnonFunDecl, DeclId(act, _, funname). 
	TransDeclAction(t, funname) :- t is TransDecl, t.src.owner.kind = REAL, act = t.action, act : String, f is FunDecl, f.owner = t.src.owner, f.name = act, DeclId(f, _, funname). 

	//// Base case
	TransDeclConcat(c, s, NIL) :- s is StateDecl, s.owner.kind = REAL, c = count({t | t is TransDecl, t.src = s}).

    //// Build every transition list in reverse order
	TransDeclConcat(m, d.src, arr) :- 
							TransDeclId(d, m, srcname, dstname, machname),
							TransDeclEvnt(d, evname, _),
							TransDeclAction(d, funname),
							TransDeclConcat(m + 1, d.src, after), 
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(IntLit(m, DEC, NIL),
							   Args(Ident(srcname),
							   Args(Ident(machname),
							   Args(Ident(evname),
							   Args(Ident(dstname),
							   Args(Ident(funname),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))))).

	COut(3, def) :- TransDeclConcat(0, state, arr),
	                QualName2CStr(state.name, statename),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_TRANSDECL"), NIL), 
								  strJoin("P_GEND_TRANS_", strJoin(state.owner.name, strJoin("_", statename))), 
								  Init(arr)).

    /*************************************************************/
    /******             Generate Do Decl Arrays             ******/
    /*************************************************************/	
	DoDeclConcat ::= (pos: Natural, context: StateDecl, arr: out.Args + {NIL}).
	DoDeclId     ::= (decl: DoDecl, id: Natural, srcName: String, machName: String).

	//// DoDeclId Id also contains source and owner machine ids
	DoDeclId(d, id, srcname, machname) :- 
	                d is DoDecl, d.action != DEFER, d.src.owner.kind = REAL,
					id = toOrdinal(d, 0, { d' | d' is DoDecl, d'.src = d.src, d'.action != DEFER }),
					DeclId(d.src, _, srcname), 
					DeclId(d.src.owner, _, machname).

    //// Do event Id depends on whether the do is a user event, default, or halt.
    DoDeclEvnt  ::= (decl: DoDecl, evName: String, id: Natural).
	DoDeclEvnt(d, evname, id) :- d is DoDecl, d.src.owner.kind = REAL, d.action != DEFER, ev is EventDecl, ev.name = d.trig, DeclId(ev, id, evname).
	DoDeclEvnt(d, evname, id) :- d is DoDecl, d.src.owner.kind = REAL, d.action != DEFER, trig = d.trig, trig : DefaultOrHalt, DeclId(trig, id, evname).

    //// Defer event Id depends on whether the do is a user event, default, or halt.
    DeferEvnt  ::= (decl: DoDecl, evName: String, id: Natural).
	DeferEvnt(d, evname, id) :- d is DoDecl, d.src.owner.kind = REAL, d.action = DEFER, ev is EventDecl, ev.name = d.trig, DeclId(ev, id, evname).
	DeferEvnt(d, evname, id) :- d is DoDecl, d.src.owner.kind = REAL, d.action = DEFER, trig = d.trig, trig : DefaultOrHalt, DeclId(trig, id, evname).

	//// Do action index depends on whether the do is an ignore or not.
    DoDeclAction  ::= (decl: DoDecl, funName: String).
	DoDeclAction(d, funname) :- d is DoDecl, d.src.owner.kind = REAL, d.action = IGNORE, funname = strJoin("_P_FUN_", strJoin(d.src.owner.name, "_PUSH_OR_IGN")). 
	DoDeclAction(d, funname) :- d is DoDecl, d.src.owner.kind = REAL, act = d.action, act : AnonOrNamedFun, DeclId(act, _, funname). 
	DoDeclAction(d, funname) :- d is DoDecl, d.src.owner.kind = REAL, act = d.action, act : String, f is FunDecl, f.owner = d.src.owner, f.name = act, DeclId(f, _, funname). 

	//// Base case
	DoDeclConcat(c, s, NIL) :- s is StateDecl, s.owner.kind = REAL, c = count({d | d is DoDecl, d.src = s, d.action != DEFER}).

    //// Build every transition list in reverse order
	DoDeclConcat(m, d.src, arr) :- 
							DoDeclId(d, m, srcname, machname),
							DoDeclEvnt(d, evname, _),
							DoDeclAction(d, funname),
							DoDeclConcat(m + 1, d.src, after), 
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(IntLit(m, DEC, NIL),
							   Args(Ident(srcname),
							   Args(Ident(machname),
							   Args(Ident(evname),
							   Args(Ident(funname),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL)))))))).

	COut(4, def) :- DoDeclConcat(0, state, arr),
	                QualName2CStr(state.name, statename),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_DODECL"), NIL), 
								  strJoin("P_GEND_DOS_", strJoin(state.owner.name, strJoin("_", statename))), 
								  Init(arr)).

    /*************************************************************/
    /******            Generate Fun Implementations         ******/
    /*************************************************************/	

	COut(5, def) :- DeclId(f, id, name), id > 0, f : FunDecl, f.kind = REAL, f.owner.kind = REAL,
	                params = Params(Param(NIL, "context"), 
						     Params(Param(NIL, "funIndex"), 
							 Params(Param(NIL, "value"), NIL))),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_SM_CONTEXT")),
					           PrmTypes(NmdType(NIL, "PRT_UINT32"),
							   PrmTypes(PtrType(NmdType(NIL, "PRT_VALUE")), NIL))),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin(name, "_IMPL"),
					  params,
					  NIL).

	COut(5, def) :- DeclId(f, id, name), id > 0, f : AnonFunDecl, f.owner.kind = REAL,
	                params = Params(Param(NIL, "context"), 
						     Params(Param(NIL, "funIndex"), 
							 Params(Param(NIL, "value"), NIL))),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_SM_CONTEXT")),
					           PrmTypes(NmdType(NIL, "PRT_UINT32"),
							   PrmTypes(PtrType(NmdType(NIL, "PRT_VALUE")), NIL))),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin(name, "_IMPL"),
					  params,
					  NIL).

	HOut(1, def) :- DeclId(f, id, name), id > 0, f : FunDecl, f.kind = MODEL, f.owner.kind = REAL,
	                params = Params(Param(NIL, "context"), 
						     Params(Param(NIL, "funIndex"), 
							 Params(Param(NIL, "value"), NIL))),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_SM_CONTEXT")),
					           PrmTypes(NmdType(NIL, "PRT_UINT32"),
							   PrmTypes(PtrType(NmdType(NIL, "PRT_VALUE")), NIL))),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin(name, "_IMPL"),
					  params,
					  UNKNOWN).
				
    /*************************************************************/
    /******            Generate Fun Decl Arrays             ******/
    /*************************************************************/	
	FunDeclConcat ::= (pos: Natural, mach: MachineDecl, arr: out.Args + {NIL}).

	//// Base case
	FunDeclConcat(c, m, NIL) :- m is MachineDecl, m.kind = REAL, c = 1 + count({f | f is AnonOrNamedFun, f.owner = m}).

    //// Build every fundecl array in reverse order
	FunDeclConcat(m, d.owner, arr) :- 
							DeclId(d, m, cfun), DeclId(d.owner, _, cmach), FunDeclConcat(m + 1, d.owner, after), d : FunDecl,							  
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(cfun),
							   Args(Ident(cmach),
							   Args(StringLit(d.name, NIL),
							   Args(UnApp(ADDR, Ident(strJoin(cfun, "_IMPL"))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

	FunDeclConcat(m, d.owner, arr) :- 
							DeclId(d, m, cfun), DeclId(d.owner, _, cmach), FunDeclConcat(m + 1, d.owner, after), d : AnonFunDecl,							  
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(cfun),
							   Args(Ident(cmach),
							   Args(Ident("NULL"),
							   Args(UnApp(ADDR, Ident(strJoin(cfun, "_IMPL"))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

	//// Reserve the zeroth decl for the push transition
	FunDeclConcat(0, m, arr) :- FunDeclConcat(1, m, after), DeclId(m, _, cmach), arr = out.Args(def, after),
	                        def = Init(
							   Args(Ident(strJoin("_P_FUN_", strJoin(m.name, "_PUSH_OR_IGN"))),
							   Args(Ident(cmach),
							   Args(Ident("NULL"),
							   Args(Ident("NULL"),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

	COut(6, def) :- FunDeclConcat(0, mach, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_FUNDECL"), NIL), 
								  strJoin("P_GEND_FUNS_", mach.name), 
								  Init(arr)).

    /*************************************************************/
    /******         Generate EventSet Decl Arrays           ******/
    /*************************************************************/	
	EventPackList ::= (dat: EventPackData, tl: EventPackList + { NIL }).
	EventPackData ::= (arrIndex: Natural, events: Natural). 
	EventPacking  ::= (list: EventPackList + { NIL }, rem: EventPackList + { NIL }, arrIndex: Natural, packArr: out.Args + { NIL }).
	EventsPacked  ::= (state: StateDecl, cntxt : { #TransDecl, #DoDecl, DEFER }, list: EventPackList + { NIL }).

	//// Generate event sets for transitions
	EventsPacked(s, #TransDecl, list),
	EventPacking(list, list, size, NIL) :- 
	     s is StateDecl, s.owner.kind = REAL, 
	     list = toList(
		           #EventPackList, 
				   NIL, 
				   { EventPackData(i, n) | 
				        TransDeclEvnt(t, _, j), t.src = s, i = qtnt(j / 32, 1), 
				        n = sum(0, { m | TransDeclEvnt(t', _, k), t'.src = s, i = qtnt(k / 32, 1), PowOf2(k % 32, m) }), n : Natural 
	               }),
		 size = 1 + maxAll(0, { i | TransDeclEvnt(t, _, j), t.src = s, i = qtnt(j / 32, 1) }), size : Natural.	

	//// Generate event sets for non-defer do's
	EventsPacked(s, #DoDecl, list),
	EventPacking(list, list, size, NIL) :- 
	     s is StateDecl, s.owner.kind = REAL, 
	     list = toList(
		           #EventPackList, 
				   NIL, 
				   { EventPackData(i, n) | 
				        DoDeclEvnt(d, _, j), d.action != DEFER, d.src = s, i = qtnt(j / 32, 1), 
				        n = sum(0, { m | DoDeclEvnt(d', _, k), d'.action != DEFER, d'.src = s, i = qtnt(k / 32, 1), PowOf2(k % 32, m) }), n : Natural 
	               }),
		 size = 1 + maxAll(0, { i | DoDeclEvnt(d, _, j), d.action != DEFER, d.src = s, i = qtnt(j / 32, 1) }), size : Natural.	

	//// Generate event sets for defer do's
	EventsPacked(s, DEFER, list),
	EventPacking(list, list, size, NIL) :- 
	     s is StateDecl, s.owner.kind = REAL, 
	     list = toList(
		           #EventPackList, 
				   NIL, 
				   { EventPackData(i, n) | 
				        DeferEvnt(d, _, j), d.action = DEFER, d.src = s, i = qtnt(j / 32, 1), 
				        n = sum(0, { m | DeferEvnt(d', _, k), d'.action = DEFER, d'.src = s, i = qtnt(k / 32, 1), PowOf2(k % 32, m) }), n : Natural 
	               }),
		 size = 1 + maxAll(0, { i | DeferEvnt(d, _, j), d.action = DEFER, d.src = s, i = qtnt(j / 32, 1) }), size : Natural.	

    //// Build up pack array.
	EventPacking(l, NIL,  i',  a') :- EventPacking(l, NIL, i, a), i > 0, i' = i - 1, i' : Natural, a' = Args(IntLit(0, HEX, U), a).
	EventPacking(l, r.tl, i',  a') :- EventPacking(l, r,   i, a), i > 0, i' = i - 1, i' : Natural, r.dat.arrIndex < i', a' = Args(IntLit(0, HEX, U), a).
	EventPacking(l, r.tl, i',  a') :- EventPacking(l, r,   i, a), i > 0, i' = i - 1, i' : Natural, r.dat.arrIndex = i', a' = Args(IntLit(r.dat.events, HEX, U), a).

	COut(7, def) :- EventPacking(l, _, 0, a),
	                id = toOrdinal(l, 0, { l' | EventsPacked(_, _, l') }),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_UINT32"), NIL), 
								  strJoin("P_GEND_EVENTSET_", toString(id)), 
								  Init(a)).

    //// Build up event sets.
	EvSetDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	//// Base case
	EvSetDeclConcat(c, NIL) :- c = count({l | EventsPacked(_, _, l) }).

    //// Build every event set array in reverse order
	EvSetDeclConcat(m, arr) :- 
	                        EventPacking(l, _, size, NIL),
	                        m = toOrdinal(l, 0, { l' | EventsPacked(_, _, l') }),
							EvSetDeclConcat(m + 1, after),							  
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(IntLit(m, DEC, NIL),
							   Args(IntLit(size, DEC, NIL),
							   Args(Ident(strJoin("P_GEND_EVENTSET_", toString(m))),
							   NIL)))).

	COut(8, def) :- EvSetDeclConcat(0, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_EVENTSETDECL"), NIL), 
								  "P_GEND_EVENTSETS", 
								  Init(arr)).

    /*************************************************************/
    /******            Generate State Decl Arrays           ******/
    /*************************************************************/	
	StateDeclConcat      ::= (pos: Natural, mach: MachineDecl, arr: out.Args + {NIL}).

	StateEventSetIndices ::= (state: StateDecl, transIndex: Natural, doIndex: Natural, deferIndex: Natural).
	StateEventSetIndices(s, ti, doi, dfi) :- 
	                     s.owner.kind = REAL,
	                     EventsPacked(s, #TransDecl, tlist),
						 ti = toOrdinal(tlist, 0, { l | EventsPacked(_, _, l) }), 
	                     EventsPacked(s, #DoDecl, dolist),
						 doi = toOrdinal(dolist, 0, { l | EventsPacked(_, _, l) }), 
	                     EventsPacked(s, DEFER, dflist),
						 dfi = toOrdinal(dflist, 0, { l | EventsPacked(_, _, l) }).

    StateEntryAction  ::= (decl: StateDecl, funName: String).
	StateEntryAction(s, funname) :- s is StateDecl, s.owner.kind = REAL, act = s.entryAction, act : AnonFunDecl, DeclId(act, _, funname). 
	StateEntryAction(s, funname) :- s is StateDecl, s.owner.kind = REAL, act = s.entryAction, act : String, f is FunDecl, f.owner = s.owner, f.name = act, DeclId(f, _, funname). 

    StateExitFun  ::= (decl: StateDecl, funName: String).
	StateExitFun(s, funname) :- s is StateDecl, s.owner.kind = REAL, act = s.exitFun, act : AnonFunDecl, DeclId(act, _, funname). 
	StateExitFun(s, funname) :- s is StateDecl, s.owner.kind = REAL, act = s.exitFun, act : String, f is FunDecl, f.owner = s.owner, f.name = act, DeclId(f, _, funname). 

    StateHandlerArrays ::= (decl: StateDecl, transArrSize: Natural, transArr: out.Ident, doArrSize: Natural, doArr: out.Ident).

	StateHandlerArrays(s, transArrSize, transArr, doArrSize, doArr) :-
		s is StateDecl, s.owner.kind = REAL, 
		transArrSize = 0, transArr = out.Ident("NULL"),
		doArrSize = 0, doArr = out.Ident("NULL"),
		transArrSize = count({ t  | t is TransDecl, t.src = s }),
		doArrSize = count({ do | do is DoDecl, do.src = s, do.action != DEFER }). 

	StateHandlerArrays(s, transArrSize, transArr, doArrSize, doArr) :-
		s is StateDecl, s.owner.kind = REAL,
		QualName2CStr(s.name, sname),
		transArrSize > 0, transArr = out.Ident(strJoin("P_GEND_TRANS_", strJoin(s.owner.name, strJoin("_", sname)))),
		doArrSize = 0, doArr = out.Ident("NULL"),
		transArrSize = count({ t  | t is TransDecl, t.src = s }),
		doArrSize = count({ do | do is DoDecl, do.src = s, do.action != DEFER }). 

	StateHandlerArrays(s, transArrSize, transArr, doArrSize, doArr) :-
		s is StateDecl, s.owner.kind = REAL,
		QualName2CStr(s.name, sname),
		transArrSize = 0, transArr = out.Ident("NULL"),
		doArrSize > 0, doArr = out.Ident(strJoin("P_GEND_DOS_", strJoin(s.owner.name, strJoin("_", sname)))),
		transArrSize = count({ t  | t is TransDecl, t.src = s }),
		doArrSize = count({ do | do is DoDecl, do.src = s, do.action != DEFER }). 

	StateHandlerArrays(s, transArrSize, transArr, doArrSize, doArr) :-
		s is StateDecl, s.owner.kind = REAL,
		QualName2CStr(s.name, sname),
		transArrSize > 0, transArr = out.Ident(strJoin("P_GEND_TRANS_", strJoin(s.owner.name, strJoin("_", sname)))),
		doArrSize > 0, doArr = out.Ident(strJoin("P_GEND_DOS_", strJoin(s.owner.name, strJoin("_", sname)))),
		transArrSize = count({ t | t is TransDecl, t.src = s }),
		doArrSize = count({ do | do is DoDecl, do.src = s, do.action != DEFER }). 
    
	//// Base case
	StateDeclConcat(c, m, NIL) :- m is MachineDecl, m.kind = REAL, c = count({s | s is StateDecl, s.owner = m}).

    //// Build every variable array in reverse order
	StateDeclConcat(m, d.owner, arr) :- 
							DeclId(d, m, cstate), 
							DeclId(d.owner, _, cmach), 
							StateDeclConcat(m + 1, d.owner, after), d : StateDecl, 
							QualName2CStr(d.name, sname),
							StateEventSetIndices(d, ti, doi, dfi),
							StateEntryAction(d, entryname),
							StateExitFun(d, exitname),
							StateHandlerArrays(d, transArrSize, transArr, doArrSize, doArr),
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(cstate),
							   Args(Ident(cmach),
							   Args(StringLit(sname, NIL),
							   Args(IntLit(transArrSize, DEC, NIL),
							   Args(IntLit(doArrSize, DEC, NIL),
							   Args(IntLit(dfi, DEC, NIL),
							   Args(IntLit(ti, DEC, NIL),
							   Args(IntLit(doi, DEC, NIL),
							   Args(transArr,
							   Args(doArr,
							   Args(Ident(entryname),
							   Args(Ident(exitname),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))))))))))).

	COut(9, def) :- StateDeclConcat(0, mach, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_STATEDECL"), NIL), 
								  strJoin("P_GEND_STATES_", mach.name), 
								  Init(arr)).

    /*************************************************************/
    /******          Generate Machine Decl Arrays           ******/
    /*************************************************************/	
	MachineDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	MachVarArr ::= (decl: MachineDecl, size: Natural, arr: out.Ident).
	MachVarArr(m, size, arr) :- m is MachineDecl, m.kind = REAL, 
	                size = 0, arr = out.Ident("NULL"),
	                size = count({ v | v is VarDecl, v.owner = m }).

	MachVarArr(m, size, arr) :- m is MachineDecl, m.kind = REAL, 
	                size > 0, arr = out.Ident(strJoin("P_GEND_VARS_", m.name)),
	                size = count({ v | v is VarDecl, v.owner = m }).

	MachStateArr ::= (decl: MachineDecl, size: Natural, arr: out.Ident).
	MachStateArr(m, size, arr) :- m is MachineDecl, m.kind = REAL, 
	                size > 0, arr = out.Ident(strJoin("P_GEND_STATES_", m.name)),
	                size = count({ s | s is StateDecl, s.owner = m }).

	MachFunArr ::= (decl: MachineDecl, size: Natural, arr: out.Ident).
	MachFunArr(m, size, arr) :- m is MachineDecl, m.kind = REAL, 
	                arr = out.Ident(strJoin("P_GEND_FUNS_", m.name)),
	                size = 1 + count({ f | f is AnonOrNamedFun, f.owner = m }).

	MachQueueSize ::= (decl: MachineDecl, size: Natural).
	MachQueueSize(m, size) :- m is MachineDecl, m.kind = REAL, m.card = NIL, size = 4294967295. 
	MachQueueSize(m, size) :- m is MachineDecl, m.kind = REAL, size = m.card.bound.

	//// Base case
	MachineDeclConcat(c, NIL) :- c = count({m | m is MachineDecl, m.kind = REAL}).

	MachineDeclConcat(m, arr) :- 
							DeclId(d, m, cmach), d.kind = REAL, d : MachineDecl,
							MachineDeclConcat(m + 1, after),  
							MachVarArr(d, varArrSize, varArrName),
							MachStateArr(d, stateArrSize, stateArrName),
							MachFunArr(d, funArrSize, funArrName),
							MachQueueSize(d, queueSize),
							QualName2CStr(d.start, sname),
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(cmach),
							   Args(StringLit(d.name, NIL),
							   Args(IntLit(varArrSize, DEC, NIL),
							   Args(IntLit(stateArrSize, DEC, NIL),
							   Args(IntLit(funArrSize, DEC, NIL),
							   Args(IntLit(queueSize, DEC, NIL),
							   Args(Ident(strJoin("P_STATE_", strJoin(d.name, strJoin("_", sname)))),
							   Args(varArrName,
							   Args(stateArrName,
							   Args(funArrName,
							   Args(UnApp(ADDR, Ident(strJoin("P_CTOR_", strJoin(d.name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("P_DTOR_", strJoin(d.name, "_IMPL")))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))))))))))).

	COut(10, def) :- MachineDeclConcat(0, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_MACHINEDECL"), NIL), 
								  "P_GEND_MACHINES", 
								  Init(arr)).

	HOut(10, def) :- m is MachineDecl, m.kind = REAL,
	                params = Params(Param(NIL, "context"), 
							 Params(Param(NIL, "value"), NIL)),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_SM_CONTEXT")),
							   PrmTypes(PtrType(NmdType(NIL, "PRT_VALUE")), NIL)),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("P_CTOR_", strJoin(m.name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(10, def) :- m is MachineDecl, m.kind = REAL,
	                params = Params(Param(NIL, "context"), NIL),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_SM_CONTEXT")), NIL),
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("P_DTOR_", strJoin(m.name, "_IMPL")),
					  params,
					  UNKNOWN).

    /*************************************************************/
    /******     Generate Model Machine Decl Arrays          ******/
    /*************************************************************/	
	ModelDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	//// Base case
	ModelDeclConcat(c, NIL) :- c = count({m | m is MachineDecl, m.kind = MODEL}).

	ModelDeclConcat(m, arr) :- 
							DeclId(d, m, cmach), d.kind = MODEL, d : MachineDecl,
							ModelDeclConcat(m + 1, after),  
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(cmach),
							   Args(StringLit(d.name, NIL),
							   Args(UnApp(ADDR, Ident(strJoin("P_CTOR_", strJoin(d.name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("P_SEND_", strJoin(d.name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("P_DTOR_", strJoin(d.name, "_IMPL")))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL)))))))).

	COut(11, def) :- ModelDeclConcat(0, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_MODELIMPLDECL"), NIL), 
								  "P_GEND_MODELS", 
								  Init(arr)).

	HOut(11, def) :- m is MachineDecl, m.kind = MODEL,
	                params = Params(Param(NIL, "context"), 
							 Params(Param(NIL, "value"), NIL)),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_SM_CONTEXT")),
							   PrmTypes(PtrType(NmdType(NIL, "PRT_VALUE")), NIL)),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("P_CTOR_", strJoin(m.name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(11, def) :- m is MachineDecl, m.kind = MODEL,
	                params = Params(Param(NIL, "context"), NIL),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_SM_CONTEXT")), NIL),
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("P_DTOR_", strJoin(m.name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(11, def) :- m is MachineDecl, m.kind = MODEL,
	                params = Params(Param(NIL, "context"), 
						     Params(Param(NIL, "evnt"), 
							 Params(Param(NIL, "payload"), NIL))),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(PtrType(NmdType(NIL, "PRT_SM_CONTEXT")),
					           PrmTypes(PtrType(NmdType(NIL, "PRT_VALUE")),
							   PrmTypes(PtrType(NmdType(NIL, "PRT_VALUE")), NIL))),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("P_SEND_", strJoin(m.name, "_IMPL")),
					  params,
					  UNKNOWN).

    /*************************************************************/
    /******            Generate Program Decl                ******/
    /*************************************************************/	

	ProgEvntArray ::= (size: Natural, arr: out.Ident).
	ProgEvntArray(size, arr) :- size = 2 + count({ e | e is EventDecl }), arr = out.Ident("P_GEND_EVENTS").

	ProgEvntSetArray ::= (size: Natural, arr: out.Ident).
	ProgEvntSetArray(size, arr) :- size = count({ l | EventsPacked(_, _, l) }), size = 0, arr = out.Ident("NULL").
	ProgEvntSetArray(size, arr) :- size = count({ l | EventsPacked(_, _, l) }), size > 0, arr = out.Ident("P_GEND_EVENTSETS").

	ProgMachArray ::= (size: Natural, arr: out.Ident).
	ProgMachArray(size, arr) :- size = count({ m | m is MachineDecl, m.kind = REAL }), size = 0, arr = out.Ident("NULL").
	ProgMachArray(size, arr) :- size = count({ m | m is MachineDecl, m.kind = REAL }), size > 0, arr = out.Ident("P_GEND_MACHINES").

	ProgModelArray ::= (size: Natural, arr: out.Ident).
	ProgModelArray(size, arr) :- size = count({ m | m is MachineDecl, m.kind = MODEL }), size = 0, arr = out.Ident("NULL").
	ProgModelArray(size, arr) :- size = count({ m | m is MachineDecl, m.kind = MODEL }), size > 0, arr = out.Ident("P_GEND_MODELS").

	HOut(12, def) :- def = out.VarDef(
							      NIL, 
								  NmdType(NIL, "PRT_PROGRAMDECL"), 
								  "P_GEND_PROGRAM", 
								  NIL).

	COut(12, def) :- ProgEvntArray(evArrSize, evArrName),
	                 ProgEvntSetArray(evSetArrSize, evSetArrName),
					 ProgMachArray(machArrSize, machArrName),
					 ProgModelArray(modelArrSize, modelArrName),
	                 def = out.VarDef(
							      NIL, 
								  NmdType(NIL, "PRT_PROGRAMDECL"), 
								  "P_GEND_PROGRAM", 
								  init),
				     init = Init(
							   Args(IntLit(evArrSize, DEC, U),
							   Args(IntLit(evSetArrSize, DEC, U),
							   Args(IntLit(machArrSize, DEC, U),
							   Args(IntLit(modelArrSize, DEC, U),
							   Args(evArrName,
							   Args(evSetArrName,
							   Args(machArrName,
							   Args(modelArrName,
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))))))).

    /*************************************************************/
    /******                 Powers of two                   ******/
    /*************************************************************/	

	PowOf2 ::= (exp: {0..31}, val: Natural).

	PowOf2(0, 1).          PowOf2(1, 2).          PowOf2(2, 4).           PowOf2(3, 8).
	PowOf2(4, 16).         PowOf2(5, 32).         PowOf2(6, 64).          PowOf2(7, 128).
	PowOf2(8, 256).        PowOf2(9, 512).        PowOf2(10, 1024).       PowOf2(11, 2048).
	PowOf2(12, 4096).      PowOf2(13, 8192).      PowOf2(14, 16384).      PowOf2(15, 32768).
	PowOf2(16, 65536).     PowOf2(17, 131072).    PowOf2(18, 262144).     PowOf2(19, 524288).
	PowOf2(20, 1048576).   PowOf2(21, 2097152).   PowOf2(22, 4194304).    PowOf2(23, 8388608).
	PowOf2(24, 16777216).  PowOf2(25, 33554432).  PowOf2(26, 67108864).   PowOf2(27, 134217728).
	PowOf2(28, 268435456). PowOf2(29, 536870912). PowOf2(30, 1073741824). PowOf2(31, 2147483648).

}	