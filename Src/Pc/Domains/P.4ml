domain P extends PStaticTyping, PStructuralTyping
{

}

domain PData
{        
    /*************************************************************/
    /****************          Type Language          ************/
    /*************************************************************/    
       
    //// The BaseType REAL is the type of real machines.
    BaseType        ::= new ({ NULL, BOOL, INT, EVENT, REAL, FOREIGN, ANY }).
    TupType         ::= new (hd: any TypeExpr, tl: any TupType + { NIL }).
    NmdTupType      ::= new (hd: any NmdTupTypeField, tl: any NmdTupType + { NIL }).
    SeqType         ::= new (x: any TypeExpr).
    MapType         ::= new (k: any TypeExpr, v: any TypeExpr).
    NmdTupTypeField ::= new (name: any String, type: any TypeExpr). 
    TypeExpr        ::= BaseType + TupType + NmdTupType + SeqType + MapType.
        
    /*************************************************************/
    /****************          Action Language        ************/
    /*************************************************************/    
                               
    //// Expressions
    Name       ::= new (name: String).
    New        ::= new (name: String, arg: any Expr + { NIL }).
    FunApp     ::= new (name: String, args: any Exprs + { NIL }).
    NulApp     ::= new (op: Integer + Boolean + { THIS, TRIGGER, PAYLOAD, NONDET, FAIRNONDET, NULL, HALT }).
    UnApp      ::= new (op: { NOT, NEG, KEYS, VALUES, SIZEOF }, arg1: any Expr).
    BinApp     ::= new (op: { ADD, SUB, MUL, INTDIV, AND, OR, EQ, NEQ, LT, LE, GT, GE, IDX, IN }, arg1: any Expr, arg2: any Expr).
    Field      ::= new (arg: any Expr, name: String + Natural).
    Default    ::= new (type: any TypeExpr). 
    Cast       ::= new (arg: any Expr, type: any TypeExpr). 
    Tuple      ::= new (body: any Exprs).
    NamedTuple ::= new (body: any NamedExprs).
    Exprs      ::= new (head: any Expr, tail: any Exprs + { NIL }).              
    NamedExprs ::= new (field: String, exp: any Expr, tail: any NamedExprs + { NIL }).
    Expr       ::= Name + New + FunApp + NulApp + UnApp + BinApp + Field + Default + Cast + Tuple + NamedTuple.
    ExprsExt   ::= Expr + Exprs + NamedExprs.

    //// Statements
    Push     ::= new (name: any QualifiedName, label: Natural).
    NewStmt  ::= new (name: String, arg: any Expr + { NIL }).
    Raise    ::= new (ev: any Expr, arg: any Expr + { NIL }).
    Send     ::= new (dest: any Expr, ev: any Expr, arg: any Expr + { NIL }).
    Monitor  ::= new (name: String, ev: any Expr, arg: any Expr + { NIL }).
    FunStmt  ::= new (name: String, args: any Exprs + { NIL }).
    NulStmt  ::= new (op: { SKIP, POP }).
    UnStmt   ::= new (op: { ASSERT }, arg1: any Expr).
    BinStmt  ::= new (op: { REMOVE, ASSIGN, INSERT }, arg1: any Expr, arg2: any Expr).
    Return   ::= new (expr: any Expr + { NIL }).
    While    ::= new (cond: any Expr, body: any Stmt).
    Ite      ::= new (cond: any Expr, true: any Stmt, false: any Stmt).
    Seq      ::= new (s1: any Stmt, s2: any Stmt).

    Stmt ::= Push + NewStmt + Raise + Send + Monitor + FunStmt + NulStmt + UnStmt + BinStmt + Return + While + Ite + Seq. 

    /*************************************************************/
    /****************  State Machine Declarations    *************/
    /*************************************************************/

    EventDecl      ::= fun (name: String -> card: any QueueConstraint, type: any TypeExpr + { NIL }).    
    MachineDecl    ::= fun (name: String -> kind: { REAL, MODEL, MONITOR }, card: any QueueConstraint, start: any QualifiedName, isMain: Boolean).
    VarDecl        ::= fun (name: String, owner: MachineDecl -> type: any TypeExpr).
    
    FunDecl        ::= fun (name: String, owner: MachineDecl -> kind: { REAL, MODEL }, params: any NmdTupType + { NIL },  return: any TypeExpr + { NIL }, body: any Stmt).
    AnonFunDecl    ::= new (owner: MachineDecl, body: any Stmt).
    
    StateDecl      ::= fun (name: any QualifiedName, owner: MachineDecl -> entryAction: any AnonFunDecl + String, exitFun: any AnonFunDecl + String, temperature: { HOT, WARM, COLD }).
    TransDecl      ::= fun (src: StateDecl, trig: String + { DEFAULT, HALT } -> dst: any QualifiedName, action: any { PUSH } + AnonFunDecl + String).
    DoDecl         ::= fun (src: StateDecl, trig: String + { DEFAULT, HALT } -> action: any { DEFER, IGNORE } + AnonFunDecl + String).

    PDecl          ::= EventDecl + MachineDecl + VarDecl + AnonFunDecl + FunDecl + StateDecl + TransDecl + DoDecl.            

    AssumeMaxInstances ::= new (bound: Natural).
    AssertMaxInstances ::= new (bound: Natural).
    QualifiedName      ::= new (name: String, qualifier: any QualifiedName + { NIL }).
    QueueConstraint    ::= AssumeMaxInstances + AssertMaxInstances + { NIL }.
    EventLabel         ::= String + { DEFAULT, HALT }.

    /*************************************************************/
    /****************          Annotations           *************/
    /*************************************************************/

    Annotation  ::= new (ant: Annotatable, key: String, value: any AnnotValue).
    Annotatable ::= EventDecl + MachineDecl + VarDecl + FunDecl + StateDecl + TransDecl + DoDecl + { NIL }.
    AnnotValue  ::= Integer + String + Boolean + { NULL }.
}

domain PStructuralTyping extends PData
{
    /*************************************************************/
	conforms no missingDecl. 
	conforms no OneDeclError(_).
	conforms no TwoDeclError(_, _).
	conforms no DeclFunError(_, _).
    /*************************************************************/

	////// Three kinds of declaration errors (and missingDecl).
    OneDeclError ::= (PDecl).
    TwoDeclError ::= (PDecl, PDecl).
    DeclFunError ::= (PDecl, String).
	
	[ rule_Classes = '"error, msg: An event has multiple definitions"']
	TwoDeclError(e1, e2) :- e1 is EventDecl, e2 is EventDecl, e1.name = e2.name, e1 != e2.
	[ rule_Classes = '"error, msg: Multiple states with the same name"']
	TwoDeclError(s1, s2) :- s1 != s2, s1 is StateDecl, s2 is StateDecl, s1.name = s2.name, s1.owner = s2.owner.
	[ rule_Classes = '"error, msg: Multiple Functions with the same name"']
	TwoDeclError(f1, f2) :- f1 != f2, f1 is FunDecl, f2 is FunDecl, f1.name = f2.name, f1.owner = f2.owner.
	[ rule_Classes = '"error, msg: Multiple variables with the same name"']
	TwoDeclError(v1, v2) :- v1 != v2, v1 is VarDecl, v2 is VarDecl, v1.name = v2.name, v1.owner = v2.owner.
	[ rule_Classes = '"error, msg: Multiple machines with the same name"']
	TwoDeclError(m1, m2) :- m1 != m2, m1 is MachineDecl, m2 is MachineDecl, m1.name = m2.name.
	[ rule_Classes = '"error, msg: Multiple Transitions over the same event"']
	TwoDeclError(t1, t2) :- t1 != t2, t1 is TransDecl, t2 is TransDecl, t1.src = t2.src, t1.trig = t2.trig.
	[ rule_Classes = '"error, msg: Multiple actions over the same event"']
	TwoDeclError(a1, a2) :- a1 != a2, a1 is DoDecl(state, owner, _), a2 is DoDecl(state, owner, _), a1.src = a2.src, a1.trig = a2.trig.
	
	//// There should be a main machine
	[rule_Classes = '"error, msg: No Main Machine"']
	missingDecl :- no MachineDecl(_, _, _, _, TRUE).
	[ rule_Classes = '"error, msg: Multiple machines are declared as main machines"']
	TwoDeclError(m1, m2) :- m1 is MachineDecl, m2 is MachineDecl, m1.isMain = TRUE, m2.isMain = TRUE, m1 != m2.
		
	//// there should be a start state in each state machine.
	[ rule_Classes = '"error, msg: no start state in machine"']
	OneDeclError(m) :- m is MachineDecl, no StateDecl(s, m , _, _, _), m.start = s.
	
	//Valid TransDecl
	[ rule_Classes = '"error, msg: transition on an undefined event"']
	OneDeclError(trns) :- trns is TransDecl, no EventDecl(trns.trig, _, _), trns.trig != DEFAULT, trns.trig != HALT.
	[rule_Classes = '"error, msg: transition to an undefined state"']
	OneDeclError(trns) :- trns is TransDecl, no StateDecl(trns.dst, trns.src.owner, _, _, _).
	
	[rule_Classes = '"error, msg: transition function not defined"']
	OneDeclError(trns) :- trns is TransDecl(_, _, _, act), act : String , no FunDecl(act, trns.src.owner, _, _, _, _).
	
	[rule_Classes = '"error, msg: function cannot take arguments"']
	OneDeclError(trns) :- trns is TransDecl(_, _, _, act), act : String , FunDecl(act, trns.src.owner, _, p, _, _), p != NIL.
	
	//valid doDecl
	[ rule_Classes = '"error, msg: action on an undefined event"']
	OneDeclError(doD) :- doD is DoDecl, no EventDecl(doD.trig, _, _), doD.trig != HALT, doD.trig != DEFAULT.
	
	[rule_Classes = '"error, msg: function not defined"']
	OneDeclError(trns) :- trns is DoDecl(_, _, act), act : String, no FunDecl(act, trns.src.owner, _, _, _, _).
	
	[rule_Classes = '"error, msg: function cannot take arguments"']
	OneDeclError(trns) :- trns is DoDecl(_, _, act), act : String , FunDecl(act, trns.src.owner, _, p, _, _), p != NIL.
	
	//Entry Exit Functions
	[rule_Classes = '"error, msg: undefined function for entry"']
	DeclFunError(s, eF) :- s is StateDecl(_, _, eF, _, _), eF : String, no FunDecl(eF, s.owner, _, _, _, _).

	[rule_Classes = '"error, msg: undefined function for exit"']
	DeclFunError(s, eF) :- s is StateDecl(_, _, _, eF, _), eF : String, no FunDecl(eF, s.owner, _, _, _, _).
	
	[rule_Classes = '"error, msg: function cannot take arguments"']
	DeclFunError(s, eF) :- s is StateDecl(_, _, eF, _, _), eF : String , FunDecl(eF, s.owner, _, p, _, _), p != NIL.
	
	[rule_Classes = '"error, msg: function cannot take arguments"']
	DeclFunError(s, eF) :- s is StateDecl(_, _, _, eF, _), eF : String , FunDecl(eF, s.owner, _, p, _, _), p != NIL.
	
	//model only in real
	[rule_Classes = '"error, msg: model functions can be declared only in real machines"']
	OneDeclError(f) :- f is FunDecl, f.owner.kind != REAL, f.kind = MODEL.
	
	//cannot have default in Monitors
	[rule_Classes = '"error, msg: default transitions not allowed in monitors"']
	OneDeclError(t) :- t is TransDecl(s, DEFAULT, _, _), s.owner.kind = MONITOR, t.trig = DEFAULT.
	
	//no defer in monitors
	[rule_Classes = '"error, msg: defer not allowed in monitor"']
	OneDeclError(d) :- d is DoDecl(s, _, DEFER), s.owner.kind = MONITOR.	
}

domain PStaticTyping extends PData
/*
[
    compiler_ProductivityCheck = "TypeOf[1]"
]
*/
{
    /*************************************************************/
	conforms no TypeOf(_, _, ERROR). 
	conforms no DupNmdSubE(_, _, _, _).
	conforms no PurityError(_, _).
	conforms no LValueError(_, _).
	conforms no BadPushLabelError(_).
    /*************************************************************/

    //// The declarations that may contain expressions or statements that should be typed.
    TypingContext ::= FunDecl + AnonFunDecl.
    
    //// The set of typeable expressions and statements.
    Typeable ::= Expr + Stmt + Exprs + NamedExprs.
    
    //// The type judgement. NIL is a placeholder for untyped constructs.
    TypeOf ::= (cntxt: TypingContext, expr: Typeable, type: TypeExpr + { ERROR, NIL }).

    //// All typing contexts anywhere in the input program.
	SubCntxt ::= sub (cntxt: TypingContext).
    
    //// All typeable subexpressions / substatements and the declarations in which they appear.
    SubSE ::= sub (cntxt: TypingContext, typeable: Typeable).

	//// True if in this context
	IsEventCnst ::= (cntxt: TypingContext, expr: Typeable, paytype: TypeExpr).

    /*************************************************************/
    /*                      Types of Expressions                 */
    /*************************************************************/
    
    //// (1) The types of nullary expressions
    TypeOf(c, e, BaseType(NULL))  :- SubSE(c, e), e = NulApp(NULL).
    TypeOf(c, e, BaseType(EVENT)) :- SubSE(c, e), e = NulApp(TRIGGER).
    TypeOf(c, e, BaseType(EVENT)) :- SubSE(c, e), e = NulApp(HALT).
	
	TypeOf(c, e, t) :- SubSE(c, e), e = NulApp(PAYLOAD), PayloadType(c, t).
	
    TypeOf(c, e, BaseType(REAL))  :- SubSE(c, e), e = NulApp(THIS), c.owner.kind = REAL.
    TypeOf(c, e, BaseType(REAL)) :- SubSE(c, e), e = NulApp(THIS), c.owner.kind = MODEL.
	[ rule_Classes = '"error, msg: Monitors cannot refer to "this""']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = NulApp(THIS), c.owner.kind = MONITOR.
    
    TypeOf(c, e, BaseType(BOOL))  :- SubSE(c, e), e = NulApp(NONDET), c.owner.kind = MODEL; SubSE(c, e), e = NulApp(NONDET), c is FunDecl(_, _, MODEL, _, _, _).
	[ rule_Classes = '"error, msg: Nondeterminitistic choice can be used only in model machine and model functions"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = NulApp(NONDET), c.owner.kind != MODEL, toSymbol(c) != #FunDecl; SubSE(c, e), e = NulApp(NONDET), c.owner.kind != MODEL, c is FunDecl, c.kind != MODEL.

    TypeOf(c, e, BaseType(BOOL))  :- SubSE(c, e), e = NulApp(FAIRNONDET), c.owner.kind = MODEL; SubSE(c, e), e = NulApp(FAIRNONDET), c is FunDecl(_, _, MODEL, _, _, _).
	[ rule_Classes = '"error, msg: Nondeterminitistic choice can be used only in model machine and model functions"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = NulApp(FAIRNONDET), c.owner.kind != MODEL, toSymbol(c) != #FunDecl; SubSE(c, e), e = NulApp(FAIRNONDET), c.owner.kind != MODEL, c is FunDecl, c.kind != MODEL.
	    
    TypeOf(c, e, BaseType(INT))   :- SubSE(c, e), e = NulApp(v), v : Integer.
    TypeOf(c, e, BaseType(BOOL))  :- SubSE(c, e), e = NulApp(v), v : Boolean.          
    
    //// (2) The types of unary expressions
    TypeOf(c, e, t)               :- SubSE(c, e), e = Default(t). 
    
    TypeOf(c, e, t)               :- SubSE(c, e), e = Tuple(e'), TypeOf(c, e', t).
     
    TypeOf(c, e, t)               :- SubSE(c, e), e = NamedTuple(e'), TypeOf(c, e', t).     

    // Variables hide the names of events, in case both have the same name.
	TypeOf(c, e, t)	              :- SubSE(c, e), e = Name(n), TypeOfFormalParam(c, n, t).
    TypeOf(c, e, t)               :- SubSE(c, e), e = Name(n), VarDecl(n, c.owner, t), no TypeOfFormalParam(c, n, _). 
    TypeOf(c, e, BaseType(EVENT)) :- SubSE(c, e), e = Name(n), EventDecl(n, _, _), no VarDecl(n, c.owner, _), no TypeOfFormalParam(c, n, _). 

    IsEventCnst(c, e, BaseType(NULL)) :- SubSE(c, e), e = Name(n), EventDecl(n, _, NIL), no VarDecl(n, c.owner, _), no TypeOfFormalParam(c, n, _). 
    IsEventCnst(c, e, pt)             :- SubSE(c, e), e = Name(n), EventDecl(n, _, pt), pt : TypeExpr, no VarDecl(n, c.owner, _), no TypeOfFormalParam(c, n, _). 

	[ rule_Classes = '"error, msg: Undefined symbol"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = Name(n), no EventDecl(n, _, _), no VarDecl(n, c.owner, _), no TypeOfFormalParam(c, n, _). 
    
    TypeOf(c, e, BaseType(BOOL))  :- SubSE(c, e), e = UnApp(NOT, e'), TypeOf(c, e', BaseType(b)), b = BOOL. 
	[ rule_Classes = '"error, msg: Operator expected a boolean value"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = UnApp(NOT, e'), TypeOf(c, e', BaseType(b)), b != BOOL. 
    
    TypeOf(c, e, BaseType(INT))   :- SubSE(c, e), e = UnApp(NEG, e'), TypeOf(c, e', BaseType(b)), b = INT. 
	[ rule_Classes = '"error, msg: Operator expected an integer value"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = UnApp(NEG, e'), TypeOf(c, e', BaseType(b)), b != INT. 
    
    TypeOf(c, e, SeqType(dom))    :- SubSE(c, e), e = UnApp(KEYS, e'), TypeOf(c, e', t), t = MapType(dom, cod). 
	[ rule_Classes = '"error, msg: Operator expected a map value"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = UnApp(KEYS, e'), TypeOf(c, e', t), toSymbol(t) != #MapType. 

    TypeOf(c, e, SeqType(cod))    :- SubSE(c, e), e = UnApp(VALUES, e'), TypeOf(c, e', t), t = MapType(dom, cod). 
	[ rule_Classes = '"error, msg: Operator expected a map value"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = UnApp(VALUES, e'), TypeOf(c, e', t), toSymbol(t) != #MapType. 

    TypeOf(c, e, BaseType(INT))   :- SubSE(c, e), e = UnApp(SIZEOF, e'), TypeOf(c, e', t), t : MapType. 
    TypeOf(c, e, BaseType(INT))   :- SubSE(c, e), e = UnApp(SIZEOF, e'), TypeOf(c, e', t), t : SeqType. 
	[ rule_Classes = '"error, msg: Operator expected a map or sequence value"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = UnApp(SIZEOF, e'), TypeOf(c, e', t), toSymbol(t) != #MapType, toSymbol(t) != #SeqType. 
    
    //// (3) The types of binary expressions
    TypeOf(c, e, t)                :- SubSE(c, e), e = Cast(e', t), TypeOf(c, e', t'), TypeRel(t, t', k), k != EMPTY.
	[ rule_Classes = '"error, msg: Cast can never succeed"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Cast(e', t), TypeOf(c, e', t'), TypeRel(t, t', k), k = EMPTY.

    TypeOf(c, e, BaseType(REAL))   :- SubSE(c, e), e = New(n, _), MachineDecl(n, REAL, _, _, _).
    TypeOf(c, e, BaseType(REAL))  :- SubSE(c, e), e = New(n, _), MachineDecl(n, MODEL, _, _, _).
	[ rule_Classes = '"error, msg: Monitors cannot be created with "new""']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = New(n, _), MachineDecl(n, MONITOR, _, _, _).
	[ rule_Classes = '"error, msg: Undefined machine type"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = New(n, _), no MachineDecl(n, _, _, _, _).   
    [ rule_Classes = '"error, msg: monitors cannot have : new | send | monitor | push | pop"']
	TypeOf(c, e, ERROR)			   :- SubSE(c, e), c.owner.kind = MONITOR, toSymbol(e) = #Send; SubSE(c, e), c.owner.kind = MONITOR, toSymbol(e) = #NewStmt; SubSE(c, e), c.owner.kind = MONITOR, toSymbol(e) = #New; SubSE(c, e), c.owner.kind = MONITOR, toSymbol(e) = #Monitor; SubSE(c, e), c.owner.kind = MONITOR, toSymbol(e) = #Push; SubSE(c, e), c.owner.kind = MONITOR, e.op = POP.
	
    TypeOf(c, e, ft)               :- SubSE(c, e), e = Field(e', n), TypeOf(c, e', t), TypeOfField(t, n, ft), ft != ERROR.
	[ rule_Classes = '"error, msg: Bad field name"']
    TypeOf(c, e, ft)               :- SubSE(c, e), e = Field(e', n), TypeOf(c, e', t), TypeOfField(t, n, ft), ft = ERROR.
	[ rule_Classes = '"error, msg: Operator expected a (named) tuple value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Field(e', n), TypeOf(c, e', t), toSymbol(t) != #TupType, toSymbol(t) != #NmdTupType.
    
    PureIntOp ::= { ADD, SUB, MUL, INTDIV }.
    TypeOf(c, e, bint)             :- SubSE(c, e), e = BinApp(op, e', e''), TypeOf(c, e', bint), TypeOf(c, e'', bint), op : PureIntOp, bint = BaseType(INT).
	[ rule_Classes = '"error, msg: Operator expected first argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, e', _), TypeOf(c, e', t), op : PureIntOp, t != BaseType(INT).    
	[ rule_Classes = '"error, msg: Operator expected second argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, _, e''), TypeOf(c, e'', t), op : PureIntOp, t != BaseType(INT).    
    
    PureIntRel ::= { LT, LE, GT, GE }.
    TypeOf(c, e, BaseType(BOOL))   :- SubSE(c, e), e = BinApp(op, e', e''), TypeOf(c, e', bint), TypeOf(c, e'', bint), op : PureIntRel, bint = BaseType(INT).
	[ rule_Classes = '"error, msg: Operator expected first argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, e', _), TypeOf(c, e', t), op : PureIntRel, t != BaseType(INT).    
	[ rule_Classes = '"error, msg: Operator expected second argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, _, e''), TypeOf(c, e'', t), op : PureIntRel, t != BaseType(INT).    
    
    PureBoolOp ::= { AND, OR }.
    TypeOf(c, e, BaseType(BOOL))   :- SubSE(c, e), e = BinApp(op, e', e''), TypeOf(c, e', bbool), TypeOf(c, e'', bbool), op : PureBoolOp, bbool = BaseType(BOOL).
	[ rule_Classes = '"error, msg: Operator expected first argument to be a boolean value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, e', _), TypeOf(c, e', t), op : PureBoolOp, t != BaseType(BOOL).    
	[ rule_Classes = '"error, msg: Operator expected second argument to be a boolean value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, _, e''), TypeOf(c, e'', t), op : PureBoolOp, t != BaseType(BOOL).    
    
    PolyRel ::= { EQ, NEQ }.
    TypeOf(c, e, BaseType(BOOL))   :- SubSE(c, e), e = BinApp(op, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), op : PolyRel, TypeRel(t', t'', k), k != EMPTY.
	[ rule_Classes = '"error, msg: Values cannot be compared because their types are incompatible"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), op : PolyRel, TypeRel(t', t'', k), k = EMPTY.
    
    TypeOf(c, e, inner)            :- SubSE(c, e), e = BinApp(IDX, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' = SeqType(inner), t'' = BaseType(INT).
    TypeOf(c, e, cod)              :- SubSE(c, e), e = BinApp(IDX, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' = MapType(dom, cod), TypeRel(t'', dom, SUB).
	[ rule_Classes = '"error, msg: Indexer must be applied to a sequence or map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(IDX, e', _), TypeOf(c, e', t'), toSymbol(t') != #SeqType, toSymbol(t') != #MapType.
	[ rule_Classes = '"error, msg: Index must be an integer"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(IDX, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' : SeqType, t'' != BaseType(INT).
	[ rule_Classes = '"error, msg: Index may not be in the domain of the map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(IDX, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' = MapType(dom, _), TypeRel(t'', dom, k), t'' != dom, k != SUB.
    
    TypeOf(c, e, BaseType(BOOL))   :- SubSE(c, e), e = BinApp(IN, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t'' = SeqType(inner), TypeRel(t', inner, k), k != EMPTY.
    TypeOf(c, e, BaseType(BOOL))   :- SubSE(c, e), e = BinApp(IN, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t'' = MapType(dom, _), TypeRel(t', dom, k), k != EMPTY.        
	[ rule_Classes = '"error, msg: Value can never be in the sequence"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(IN, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t'' = SeqType(inner), TypeRel(t', inner, EMPTY).
	[ rule_Classes = '"error, msg: Value can never be in the map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(IN, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t'' = MapType(dom, _), TypeRel(t', dom, EMPTY).        
	[ rule_Classes = '"error, msg: "in" expects a sequence or map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(IN, _, e''),  TypeOf(c, e'', t''), toSymbol(t'') != #SeqType, toSymbol(t'') != #MapType.
    
	///// (4) Exprs produces a tuple type
	TypeOf(c, e, t) :- SubSE(c, e), e = Exprs(e', NIL), TypeOf(c, e', t'), t = TupType(t', NIL).
	TypeOf(c, e, t) :- SubSE(c, e), e = Exprs(e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t'' : TupType, t = TupType(t', t'').
		
	//// (5) NamedExprs produces a named tuple type.
	TypeOf(c, e, t) :- SubSE(c, e), e = NamedExprs(n', e', NIL), TypeOf(c, e', t'), t = NmdTupType(NmdTupTypeField(n', t'), NIL).
	TypeOf(c, e, t) :- SubSE(c, e), e = NamedExprs(n', e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t'' : NmdTupType, t = NmdTupType(NmdTupTypeField(n', t'), t'').
	
	//// (6) FunApps must refer to a defined function that has a non-NIL return type and args must be sub-types of function signature. 
	TypeOf(c, e, t)     :- SubSE(c, e), e = FunApp(n, NIL), FunDecl(n, c.owner, _, NIL, t, _), t != NIL.
	TypeOf(c, e, t)     :- SubSE(c, e), e = FunApp(n, e'), TypeOf(c, e', argt), decl is FunDecl(n, c.owner, _, _, t, _), FuncSigTupleType(decl, inpt), TypeRel(argt, inpt, SUB), t != NIL.

	[ rule_Classes = '"error, msg: function not defined"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, _), no FunDecl(n, c.owner, _, _, _, _).	
	[ rule_Classes = '"error, msg: function does not return a value"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, _), FunDecl(n, c.owner, _, _, NIL, _).
	[ rule_Classes = '"error, msg: function requires arguments"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, NIL), FunDecl(n, c.owner, _, params, _, _), params != NIL.
	[ rule_Classes = '"error, msg: function arguments have incorrect types"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, e'), TypeOf(c, e', argt), decl is FunDecl(n, c.owner, _, _, _, _), FuncSigTupleType(decl, inpt), TypeRel(argt, inpt, k), argt != inpt, k != SUB.
	
    /*************************************************************/
    /*                      Types of Statements                  */
    /*************************************************************/

	//// (1) Nullary statements
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = NulStmt(SKIP).
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = NulStmt(POP).

	//// (2) Return statement
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Return(NIL), c = FunDecl(_, _, _, _, NIL, _). 
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Return(NIL), c : AnonFunDecl.
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Return(e'), c = FunDecl(_, _, _, _, t, _), TypeOf(c, e', t'), TypeRel(t', t, SUB).
	[ rule_Classes = '"error, msg: function must return a value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Return(NIL), c = FunDecl(_, _, _, _, t, _), t != NIL. 
	[ rule_Classes = '"error, msg: return value has incorrect type"' ]
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Return(e'), c = FunDecl(_, _, _, _, t, _), TypeOf(c, e', t'), TypeRel(t', t, k), t' != t, k != SUB.
	[ rule_Classes = '"error, msg: anonymous function cannot return a value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Return(t), c : AnonFunDecl, t != NIL. 

	//// (3) Non-mutating statements
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Seq(_, _).
    
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = UnStmt(ASSERT, e'), TypeOf(c, e', t'), t' = BaseType(BOOL).
	[ rule_Classes = '"error, msg: "assert" expects a boolean value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = UnStmt(ASSERT, e'), TypeOf(c, e', t'), t' != BaseType(BOOL).
    
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Ite(e', _, _), TypeOf(c, e', t'), t' = BaseType(BOOL).
	[ rule_Classes                                   = '"error, msg: "if (...)" expects a boolean value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Ite(e', _, _), TypeOf(c, e', t'), t' != BaseType(BOOL).
    
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = While(e', _), TypeOf(c, e', t'), t' = BaseType(BOOL).
	[ rule_Classes = '"error, msg: "while (...)" expects a boolean value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = While(e', _), TypeOf(c, e', t'), t' != BaseType(BOOL).
               
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Push(name, _), StateDecl(name, c.owner, _, _, _). 
	[ rule_Classes = '"error, msg: Undeclared state name"']
	TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Push(name, _), no StateDecl(name, c.owner, _, _, _). 
    
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = NewStmt(n, _), MachineDecl(n, _, _, _, _).   
	[ rule_Classes = '"error, msg: Undeclared machine"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = NewStmt(n, _), no MachineDecl(n, _, _, _, _).   
    
	//// Rules for raise with non-constant event expression.
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Raise(ev, _), TypeOf(c, ev, evt), evt = BaseType(EVENT), no IsEventCnst(c, ev, _).

	//// Rules for raise with constant event expression.
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Raise(ev, NIL),                            ///// < raise has NIL payload,
	                                  IsEventCnst(c, ev, evt), TypeRel(BaseType(NULL), evt, SUB). ///// < event type contains null.

    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Raise(ev, p), p != NIL,                          ///// < raise has non-NIL payload,             
	                                  IsEventCnst(c, ev, evt), TypeOf(c, p, pt), TypeRel(pt, evt, SUB). ///// < and pt is a subtype of evt.

	//// Error rules for raise.
	[ rule_Classes = '"error, msg: argument 1 of "raise" expects an event value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Raise(ev, _), TypeOf(c, ev, evt), evt != BaseType(EVENT).

	//// Error rules for raise with constant event expression. 	
    [ rule_Classes = '"error, msg: invalid payload type in raise (cannot send null value)"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Raise(ev, NIL), null = BaseType(NULL),   ///// < raise has NIL payload,
	                                  IsEventCnst(c, ev, evt),                                  ///// < constant event expression
									  TypeRel(null, evt, k), k != SUB, null != evt.             ///// < and null not in event type.

    [ rule_Classes = '"error, msg: invalid payload type in raise"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Raise(ev, p), p != NIL,                    ///// < p has non-NIL payload,             
	                                  IsEventCnst(c, ev, evt),                                    ///// < constant event expression
									  TypeOf(c, p, pt), TypeRel(pt, evt, k), k != SUB, pt != evt. ///// < and pt is not a subtype of evt.

	//// Rules for send with non-constant event expression.
	RealOrModel ::= { REAL, MODEL }.  
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Send(m, ev, _),  
	                                  TypeOf(c, m, mt), mt = BaseType(mk), mk : RealOrModel,                ///// < m is a machine type,
	                                  TypeOf(c, ev, evt), evt = BaseType(EVENT), no IsEventCnst(c, ev, _).  ///// < ev is a non-constant event type.

	//// Rules for send with constant event expression.
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Send(m, ev, NIL),                          ///// < send has NIL payload,
	                                  TypeOf(c, m, mt), mt = BaseType(mk), mk : RealOrModel,      ///// < m is a machine type,
	                                  IsEventCnst(c, ev, evt), TypeRel(BaseType(NULL), evt, SUB). ///// < event type contains null.

    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Send(m, ev, p), p != NIL,                        ///// < send has non-NIL payload,             
	                                  TypeOf(c, m, mt), mt = BaseType(mk), mk : RealOrModel,            ///// < m is a machine type,
	                                  IsEventCnst(c, ev, evt), TypeOf(c, p, pt), TypeRel(pt, evt, SUB). ///// < and pt is a subtype of evt.

	//// Error rules for send.
	[ rule_Classes = '"error, msg: argument 1 of "send" expects a machine value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Send(m, _, _), TypeOf(c, m, mt), mt != BaseType(REAL).

	[ rule_Classes = '"error, msg: argument 2 of "send" expects an event value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Send(_, ev, _), TypeOf(c, ev, evt), evt != BaseType(EVENT).

	//// Error rules for send with constant event expression. 	
    [ rule_Classes = '"error, msg: invalid payload type in send (cannot send null value)"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Send(_, ev, NIL), null = BaseType(NULL),   ///// < send has NIL payload,
	                                  IsEventCnst(c, ev, evt),                                    ///// < constant event expression
									  TypeRel(null, evt, k), k != SUB, null != evt.               ///// < and null not in event type.

    [ rule_Classes = '"error, msg: invalid payload type in send"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Send(_, ev, p), p != NIL,                  ///// < p has non-NIL payload,             
	                                  IsEventCnst(c, ev, evt),                                    ///// < constant event expression
									  TypeOf(c, p, pt), TypeRel(pt, evt, k), k != SUB, pt != evt. ///// < and pt is not a subtype of evt.

	//// Rules for monitor with non-constant event expression.
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Monitor(m, ev, _),  
	                                  MachineDecl(m, MONITOR, _, _, _),                                     ///// < m is a monitor type,
	                                  TypeOf(c, ev, evt), evt = BaseType(EVENT), no IsEventCnst(c, ev, _).  ///// < ev is a non-constant event type.

	//// Rules for monitor with constant event expression.
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Monitor(m, ev, NIL),                       ///// < monitor has NIL payload,
	                                  MachineDecl(m, MONITOR, _, _, _),                           ///// < m is a monitor type,
	                                  IsEventCnst(c, ev, evt), TypeRel(BaseType(NULL), evt, SUB). ///// < event type contains null.

    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Monitor(m, ev, p), p != NIL,                     ///// < monitor has non-NIL payload,             
	                                  MachineDecl(m, MONITOR, _, _, _),                                 ///// < m is a monitor type,
	                                  IsEventCnst(c, ev, evt), TypeOf(c, p, pt), TypeRel(pt, evt, SUB). ///// < and pt is a subtype of evt.

	//// Error rules for monitor.
	[ rule_Classes = '"error, msg: Undeclared monitor"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Monitor(m, _, _), no MachineDecl(m, MONITOR, _, _, _).

	[ rule_Classes = '"error, msg: argument 2 of "monitor" expects an event value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Monitor(_, ev, _), TypeOf(c, ev, evt), evt != BaseType(EVENT).

	//// Error rules for monitor with constant event expression. 	
    [ rule_Classes = '"error, msg: invalid payload type in monitor (cannot send null value)"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Monitor(_, ev, NIL), null = BaseType(NULL), ///// < monitor has NIL payload,
	                                  IsEventCnst(c, ev, evt),                                     ///// < constant event expression
									  TypeRel(null, evt, k), k != SUB, null != evt.                ///// < and null not in event type.

    [ rule_Classes = '"error, msg: invalid payload type in monitor"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Monitor(_, ev, p), p != NIL,               ///// < p has non-NIL payload,             
	                                  IsEventCnst(c, ev, evt),                                    ///// < constant event expression
									  TypeOf(c, p, pt), TypeRel(pt, evt, k), k != SUB, pt != evt. ///// < and pt is not a subtype of evt.

	//// (4) Mutating statements		
	TypeOf(c, e, NIL)			   :- SubSE(c, e), e = BinStmt(ASSIGN, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), TypeRel(t2, t1, SUB).
	[ rule_Classes = '"error, msg: invalid assignment. right hand side is not a subtype of left hand side"']
	TypeOf(c, e , ERROR)		   :- SubSE(c, e), e = BinStmt(ASSIGN, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), TypeRel(t2, t1, k), k!= SUB, t1 != t2.
		
	TypeOf(c, e, NIL)			   :- SubSE(c, e), e = BinStmt(REMOVE, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 : SeqType, t2 = BaseType(INT).
	TypeOf(c, e, NIL)			   :- SubSE(c, e), e = BinStmt(REMOVE, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = MapType(dom, cod), TypeRel(t2, dom, SUB).	
	[ rule_Classes = '"error, msg: remove must be applied to a sequence or map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinStmt(REMOVE, e', _), TypeOf(c, e', t'), toSymbol(t') != #SeqType, toSymbol(t') != #MapType.
    [ rule_Classes = '"error, msg: index must be an integer"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinStmt(REMOVE, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' : SeqType, t'' != BaseType(INT).
	[ rule_Classes = '"error, msg: Index may not be in the domain of the map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinStmt(REMOVE, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' = MapType(dom, _), TypeRel(t'', dom, k), t'' != dom, k != SUB.
	
	
	TypeOf(c, e, NIL)			   :- SubSE(c, e), e = BinStmt(INSERT, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = SeqType(inner), t2 = TupType(BaseType(INT), TupType(value, NIL)), TypeRel(value, inner, SUB).
	TypeOf(c, e, NIL)			   :- SubSE(c, e), e = BinStmt(INSERT, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)), TypeRel(value, cod, SUB), TypeRel(key, dom, SUB).	
	[ rule_Classes = '"error, msg: insert must be applied to a sequence or a map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinStmt(INSERT, e', _), TypeOf(c, e', t'), toSymbol(t') != #SeqType, toSymbol(t') != #MapType.
	[ rule_Classes = '"error, msg: for insert right syntax is seq += (index value) or map += (key value)"']
	TypeOf(c, e, ERROR)			   :- SubSE(c, e), e = BinStmt(INSERT, _, arg2), TypeOf(c, arg2, t2), toSymbol(t2) != #TupType; 
	                                  SubSE(c, e), e = BinStmt(INSERT, _, arg2), TypeOf(c, arg2, t2), t2 : TupType, lstLength(#TupType, t2) != 2.
    [ rule_Classes = '"error, msg: key must be an integer"']
    TypeOf(c, e, ERROR)			   :- SubSE(c, e), e = BinStmt(INSERT, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = SeqType(inner), t2 = TupType(idx, TupType(value, NIL)), idx != BaseType(INT).	
    [ rule_Classes = '"error, msg: value must be a subtype of sequence type"']
    TypeOf(c, e, ERROR)			   :- SubSE(c, e), e = BinStmt(INSERT, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = SeqType(inner), t2 = TupType(idx, TupType(value, NIL)), TypeRel(value, inner, k), k != SUB, value != inner.	
	[ rule_Classes = '"error, msg: key not in the domain of the map"']
    TypeOf(c, e, ERROR)			   :- SubSE(c, e), e = BinStmt(INSERT, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)), TypeRel(key, dom, k), k != SUB, key != dom.	
	[ rule_Classes = '"error, msg: value not in the codomain of the map"']
    TypeOf(c, e, ERROR)			   :- SubSE(c, e), e = BinStmt(INSERT, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)), TypeRel(value, cod, k), k != SUB, value != cod.
	
	//// (5) Function statements
	TypeOf(c, e, NIL)   :- SubSE(c, e), e = FunStmt(n, NIL), FunDecl(n, c.owner, _, NIL, _, _).
	TypeOf(c, e, NIL)   :- SubSE(c, e), e = FunStmt(n, e'), TypeOf(c, e', argt), decl is FunDecl(n, c.owner, _, _, _, _), FuncSigTupleType(decl, inpt), TypeRel(argt, inpt, SUB).
	[ rule_Classes = '"error, msg: function not defined"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, _), no FunDecl(n, c.owner, _, _, _, _).	
	[ rule_Classes = '"error, msg: function requires arguments"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, NIL), FunDecl(n, c.owner, _, params, _, _), params != NIL.
	[ rule_Classes = '"error, msg: function arguments have incorrect types"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, e'), TypeOf(c, e', argt), decl is FunDecl(n, c.owner, _, _, _, _), FuncSigTupleType(decl, inpt), TypeRel(argt, inpt, k), argt != inpt, k != SUB.

    /*************************************************************/
    /*                      Field helpers                        */
    /*************************************************************/

	TOrNTType      ::= TupType + NmdTupType.
	FieldLabel     ::= String + Natural.
    TypeOfField    ::= (tupTyp: TOrNTType, lookup: FieldLabel, fieldType: TypeExpr + { ERROR }).    
    TypeOfFieldAux ::= (tupTyp: TOrNTType, lookup: FieldLabel, fieldType: TypeExpr + { ERROR }, pos: Natural, tail: TOrNTType + { NIL }).

    TypeOfFieldAux(ttup, n, ERROR, 0, ttup)  :- SubSE(c, e), e = Field(e', n), TypeOf(c, e', ttup), ttup : TOrNTType.    
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, ERROR, pos, aux), n = pos, pos' = pos + 1, aux = TupType(t, tl).
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, ERROR, pos, aux), n = pos, pos' = pos + 1, aux = NmdTupType(NmdTupTypeField(_, t), tl).
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, ERROR, pos, aux), pos' = pos + 1, aux = NmdTupType(NmdTupTypeField(n, t), tl).

    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, t, pos, aux), n != pos, pos' = pos + 1, aux = TupType(_, tl).
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, t, pos, aux), n != pos, n != fn, pos' = pos + 1, aux = NmdTupType(NmdTupTypeField(fn, _), tl).

    TypeOfField(ttup, n, ft)                 :- TypeOfFieldAux(ttup, n, ft, _, NIL).    
	TypeOfField(ttup, n, ERROR)              :- TypeOfFieldAux(ttup, n, ERROR, 0, ttup), n : String, ttup : TupType.

    /*************************************************************/
    /*                  Formal Parameter Types                   */
    /*************************************************************/
    TypeOfFormalParam    ::= (cntxt: FunDecl, name: String, type: TypeExpr + { ERROR }).
    TypeOfFormalParamAux ::= (cntxt: FunDecl, name: String, type: TypeExpr, aux: NmdTupType + { NIL }).

    TypeOfFormalParamAux(cntxt, name, type, tl) :- cntxt is FunDecl(_, _, _, params, _, _), params = NmdTupType(NmdTupTypeField(name, type), tl).  
    TypeOfFormalParamAux(cntxt, name, type, tl) :- TypeOfFormalParamAux(cntxt, _, _, aux), aux = NmdTupType(NmdTupTypeField(name, type), tl).
    
    TypeOfFormalParam(cntxt, name, type)  :- TypeOfFormalParamAux(cntxt, name, type, aux), no { aux' | TypeOfFormalParamAux(cntxt, name, _, aux'), aux != aux' }.      
	//// This error is generated as part of DupNmdSubE
    TypeOfFormalParam(cntxt, name, ERROR) :- TypeOfFormalParamAux(cntxt, name, _, aux), TypeOfFormalParamAux(cntxt, name, _, aux'), aux != aux'.

	//// The input type of a function, ignoring names.
	FuncSigTupleType    ::= (cntxt: FunDecl, type: TupType + { NIL }).
	FuncSigTupleTypeAux ::= (cntxt: FunDecl, type: TupType + { NIL }, aux: NmdTupType + { NIL }).

	FuncSigTupleTypeAux(cntxt, params, NIL) :- cntxt is FunDecl(_, _, _, params, _, _), params = NIL.
	FuncSigTupleTypeAux(cntxt, type, tl)    :- cntxt is FunDecl(_, _, _, params, _, _), params = NmdTupType(NmdTupTypeField(_, t), tl), type = TupType(t, NIL).
	FuncSigTupleTypeAux(cntxt, type, tl)    :- FuncSigTupleTypeAux(cntxt, t', aux), aux = NmdTupType(NmdTupTypeField(_, t), tl), type = TupType(t, t').
	FuncSigTupleType(cntxt, type)           :- FuncSigTupleTypeAux(cntxt, t, NIL), type = lstReverse(#TupType, t).

    /*************************************************************/
    /* Check that named tuple (types) don't reuse the same name  */
    /*************************************************************/
	NmdList       ::= NmdTupType + NamedExprs.
	NmdListOrNone ::= NmdTupType + NamedExprs + { NIL }.

	NmdSubE     ::= sub (NmdList).
	MaxNmdSubE  ::=     (NmdList).
	NmdSubNames ::=     (list: NmdList, name: String, aux: NmdListOrNone). 
	DupNmdSubE  ::=     (list: NmdList, name: String, aux1: NmdListOrNone, aux2: NmdListOrNone).

	MaxNmdSubE(e) :- NmdSubE(e), no NmdSubE(NmdTupType(_, e)), no NmdSubE(NamedExprs(_, _, e)).
	NmdSubNames(list, name, tl) :- MaxNmdSubE(list), list = NmdTupType(NmdTupTypeField(name, _), tl). 
	NmdSubNames(list, name, tl) :- MaxNmdSubE(list), list = NamedExprs(name, _, tl). 
	NmdSubNames(list, name, tl) :- NmdSubNames(list, _, aux), aux = NmdTupType(NmdTupTypeField(name, _), tl). 
	NmdSubNames(list, name, tl) :- NmdSubNames(list, _, aux), aux = NamedExprs(name, _, tl). 

    [ rule_Classes = '"error, msg: same name appears more than once in name tuple or named tuple type"']
	DupNmdSubE(list, name, tl, tl') :- NmdSubNames(list, name, tl), NmdSubNames(list, name, tl'), tl != tl'.

    /*************************************************************/
    /*                          L-values                         */
    /*************************************************************/
	LValueError    ::= (cntxt: TypingContext, stmt: BinStmt).
	BinStmtSubExpr ::= sub (cntxt: TypingContext, stmt: BinStmt, expr: Expr).
	IsLValue       ::=     (cntxt: TypingContext, expr: Expr, writesGlobal: Boolean). 		
    IsLValue(c, e, FALSE)  :- BinStmtSubExpr(c, _, e), e = Name(n), TypeOfFormalParam(c, n, _). 
    IsLValue(c, e, TRUE)   :- BinStmtSubExpr(c, _, e), e = Name(n), VarDecl(n, c.owner, t), no TypeOfFormalParam(c, n, _). 
    IsLValue(c, e, wg)     :- BinStmtSubExpr(c, _, e), e = Field(e', _), IsLValue(c, e', wg). 
    IsLValue(c, e, wg)     :- BinStmtSubExpr(c, _, e), e = BinApp(IDX, e', _), IsLValue(c, e', wg). 

    [ rule_Classes = '"error, msg: invalid LHS; must have the form LHS ::= var | LHS[expr] | LHS.name"']
	LValueError(c, e) :- SubSE(c, e), e = BinStmt(_, e', _), no IsLValue(c, e', _).

    /*************************************************************/
    /*                      Control Impurity                     */
    /*************************************************************/
    PurityError ::= (cntxt: TypingContext + StateDecl + TransDecl, expr: Typeable + String + AnonFunDecl).

	ControlImpure ::= (TypingContext).
	ControlImpure(c) :- SubSE(c, e), e : Raise.
	ControlImpure(c) :- SubSE(c, e), e : Push.
	ControlImpure(c) :- SubSE(c, e), e = NulStmt(POP).

    [ rule_Classes = '"error, msg: function may cause a change in current state; this is not allowed here"']
    PurityError(c, e) :- 
       SubSE(c, e), e = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), ControlImpure(called).

    [ rule_Classes = '"error, msg: function may cause a change in current state; this is not allowed here"']
    PurityError(c, e) :- 
       SubSE(c, e), e = FunStmt(n, _), called is FunDecl(n, c.owner, _, _, _, _), ControlImpure(called).

    [ rule_Classes = '"error, msg: function may cause a change in current state; this is not allowed here"']
    PurityError(c, n) :- 
	       c is StateDecl(_, owner, _, n, _), called is FunDecl(n, owner, _, _, _, _), ControlImpure(called).

    [ rule_Classes = '"error, msg: function may cause a change in current state; this is not allowed here"']
    PurityError(c, called) :- 
	       c is StateDecl(_, owner, _, called, _), called = AnonFunDecl(owner, _), ControlImpure(called).

    [ rule_Classes = '"error, msg: function may cause a change in current state; this is not allowed here"']
    PurityError(c, n) :- 
	       c is TransDecl(src, _, _, n), called is FunDecl(n, src.owner, _, _, _, _), ControlImpure(called).

    [ rule_Classes = '"error, msg: function may cause a change in current state; this is not allowed here"']
    PurityError(c, called) :- 
	       c is TransDecl(src, _, _, called), called = AnonFunDecl(src.owner, _), ControlImpure(called).

    /*************************************************************/
    /*                         Push Labels                       */
    /*************************************************************/
    BadPushLabelError ::= (TypingContext).

	//// Every push statement must have a label that is unique within a context.
	//// This constraint simplifies P compilers.
	
	//// A term path describes how to reach a term.
	//// 0 means this term is reached by following the 1st child stmt of the parent term.
	//// 1 means this term is reached by following the 2nd child stmt of the parent term.
	TermPath    ::= (child: { 0, 1 }, prev: TermPath + { NIL }).
	ReachedPush ::= (cntxt: TypingContext, stmt: Stmt, path: TermPath + { NIL }).
	ReachedPush(c, c.body, NIL) :- SubCntxt(c).
	ReachedPush(c, s', p')  :- ReachedPush(c, s, p), s = While(_, s'),  p' = TermPath(0, p).
	ReachedPush(c, s', p')  :- ReachedPush(c, s, p), s = Ite(_, s', _), p' = TermPath(0, p).
	ReachedPush(c, s', p')  :- ReachedPush(c, s, p), s = Ite(_, _, s'), p' = TermPath(1, p).
	ReachedPush(c, s', p')  :- ReachedPush(c, s, p), s = Seq(s', _),    p' = TermPath(0, p).
	ReachedPush(c, s', p')  :- ReachedPush(c, s, p), s = Seq(_, s'),    p' = TermPath(1, p).

    [ rule_Classes = '"error, msg: function contains bad labeling of push statements"']
	BadPushLabelError(c) :-
	    ReachedPush(c, s, p), ReachedPush(c, s', p'), s : Push, s' : Push, s.label = s'.label, p != p'.
	
    /*************************************************************/
    /*                         Data Impurity                     */
    /*************************************************************/
	DataImpure ::= (FunDecl).

	DataImpure(c) :- SubSE(c, e), c : FunDecl, e = BinStmt(_, e', e''), IsLValue(c, e', TRUE).
	DataImpure(c) :- SubSE(c, e), e = FunApp(n, _), c : FunDecl, called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called).
	DataImpure(c) :- SubSE(c, e), e = FunStmt(n, _), c : FunDecl, called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called).

    [ rule_Classes = '"error, msg: this function must be pure. Data impure functions can only be called like "foo(...);" or "x = foo(...);" "']
    PurityError(c, e') :- 
       SubSE(c, e), e = New(_, e'),           e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);
       SubSE(c, e), e = UnApp(_, e'),         e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);
       SubSE(c, e), e = BinApp(_, e', _),     e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);
       SubSE(c, e), e = BinApp(_, _, e'),     e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);    
       SubSE(c, e), e = Field(e', _),         e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);
       SubSE(c, e), e = Cast(e', _),          e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);    
       SubSE(c, e), e = Exprs(e', _),         e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);              
       SubSE(c, e), e = NamedExprs(_, e', _), e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);
       SubSE(c, e), e = NewStmt(_, e'),       e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);
       SubSE(c, e), e = Raise(e', _),         e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);
       SubSE(c, e), e = Raise(_, e'),         e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);        
       SubSE(c, e), e = Send(e', _, _),       e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);
       SubSE(c, e), e = Send(_, e', _),       e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);
       SubSE(c, e), e = Send(_, _, e'),       e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);    
       SubSE(c, e), e = Monitor(_, e', _),    e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);
       SubSE(c, e), e = Monitor(_, _, e'),    e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);    
       SubSE(c, e), e = UnStmt(_, e'),        e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);
       SubSE(c, e), e = Return (e'),          e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);
       SubSE(c, e), e = While(e', _),         e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);
       SubSE(c, e), e = Ite(e', _, _),        e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);
       SubSE(c, e), e = BinStmt(_, e', _),    e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called);
       SubSE(c, e), e = BinStmt(_, e', e''),  e'' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), DataImpure(called), toSymbol(e') != #Name.
							                                          
    /*************************************************************/
    /*                      Type Comparability                   */
    /*************************************************************/
    //// These are the pairs of types whose relationships must be computed.
    CompTypeRel ::= (TypeExpr + { NIL, ERROR }, TypeExpr + { NIL, ERROR }).
    CompTypeRel(ta', tb')                    :- CompTypeRel(ta, tb), ta = SeqType(ta'), tb = SeqType(tb').
    CompTypeRel(da, db), CompTypeRel(ca, cb) :- CompTypeRel(ta, tb), ta = MapType(da, ca), tb = MapType(db, cb).
    CompTypeRel(la, lb), CompTypeRel(ra, rb) :- CompTypeRel(ta, tb), ta = TupType(la, ra), tb = TupType(lb, rb).
    CompTypeRel(la, lb), CompTypeRel(ra, rb) :- CompTypeRel(ta, tb), ta = NmdTupType(lfa, ra), tb = NmdTupType(lfb, rb), la = lfa.type, lb = lfb.type.
    
    CompTypeRel(t, t')        :- SubSE(c, e), e = Cast(e', t), TypeOf(c, e', t').
    CompTypeRel(t', t'')      :- SubSE(c, e), e = BinApp(op, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), op : PolyRel.
    CompTypeRel(t'', dom)     :- SubSE(c, e), e = BinApp(IDX, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' = MapType(dom, _).
    CompTypeRel(t', inner)    :- SubSE(c, e), e = BinApp(IN, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t'' = SeqType(inner).
    CompTypeRel(t', dom)      :- SubSE(c, e), e = BinApp(IN, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t'' = MapType(dom, _).
    CompTypeRel(argt, inpt)   :- SubSE(c, e), e = FunApp(n, e'), TypeOf(c, e', argt), decl is FunDecl(n, c.owner, _, _, t, _), FuncSigTupleType(decl, inpt), t != NIL.
    CompTypeRel(t', t)        :- SubSE(c, e), e = Return(e'), c = FunDecl(_, _, _, _, t, _), TypeOf(c, e', t').
    CompTypeRel(null, evt)    :- SubSE(c, e), e = Send(_, ev, NIL), IsEventCnst(c, ev, evt), null = BaseType(NULL).
    CompTypeRel(pt, evt)      :- SubSE(c, e), e = Send(_, ev, p), p != NIL, IsEventCnst(c, ev, evt), TypeOf(c, p, pt).    
    CompTypeRel(null, evt)    :- SubSE(c, e), e = Raise(ev, NIL), null = BaseType(NULL), IsEventCnst(c, ev, evt).
    CompTypeRel(pt, evt)      :- SubSE(c, e), e = Raise(ev, p), p != NIL, IsEventCnst(c, ev, evt), TypeOf(c, p, pt).
    CompTypeRel(null, evt)    :- SubSE(c, e), e = Monitor(_, ev, NIL), null = BaseType(NULL), IsEventCnst(c, ev, evt).
    CompTypeRel(pt, evt)      :- SubSE(c, e), e = Monitor(_, ev, p), p != NIL, IsEventCnst(c, ev, evt), TypeOf(c, p, pt).
    CompTypeRel(t2, t1)       :- SubSE(c, e), e = BinStmt(ASSIGN, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2).
    CompTypeRel(t2, dom)      :- SubSE(c, e), e = BinStmt(REMOVE, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = MapType(dom, _).
    CompTypeRel(value, inner) :- SubSE(c, e), e = BinStmt(INSERT, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = SeqType(inner), t2 = TupType(BaseType(INT), TupType(value, NIL)).
    CompTypeRel(value, cod)   :- SubSE(c, e), e = BinStmt(INSERT, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)).	
    CompTypeRel(key, dom)     :- SubSE(c, e), e = BinStmt(INSERT, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)).	
    CompTypeRel(argt, inpt)   :- SubSE(c, e), e = FunStmt(n, e'), TypeOf(c, e', argt), decl is FunDecl(n, c.owner, _, _, _, _), FuncSigTupleType(decl, inpt).
    
    //// TypeRel determines the relationship type expressions ta and tb.
    //// If types are not subtype related, then they can
    //// either have an empty (EMPTY) or nonempty (NONEMPTY) intersection. 
    TypeRel ::= (ta: TypeExpr + { ERROR, NIL }, tb: TypeExpr + { ERROR, NIL }, rel: { SUB, SUP, EMPTY, NONEMPTY }).
                            
    //// (1) Type (non-) emptiness.       
    // For convenience, the ERROR type is incomparable to all types, even itself.
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = ERROR.
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), s = ERROR.
    
    // For convenience, the NIL type is incomparable to all types, except itself.
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = NIL, t != NIL.
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), s = NIL, t != NIL.
    
    // The NULL type has empty intersections with NonNullBase and complex types.
    NonNullBase ::= { BOOL, INT, FOREIGN }.
    ComplexType ::= TupType  + NmdTupType + SeqType + MapType.
    TypeRel(s, t, EMPTY)   :- CompTypeRel(s, t), s = BaseType(kt), kt : NonNullBase, t = BaseType(NULL).
    TypeRel(t, s, EMPTY)   :- CompTypeRel(t, s), s = BaseType(kt), kt : NonNullBase, t = BaseType(NULL).
    
    TypeRel(s, t, EMPTY)   :- CompTypeRel(s, t), s : ComplexType, t = BaseType(NULL).
    TypeRel(t, s, EMPTY)   :- CompTypeRel(t, s), s : ComplexType, t = BaseType(NULL).
        
    // NonNullBase types have empty intersections with all types, except themselves and ANY.
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = BaseType(ks), ks : NonNullBase, s != t, t != BaseType(ANY).
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), s = BaseType(ks), ks : NonNullBase, s != t, t != BaseType(ANY).

    // NullBase types have empty intersections with all types, except themselves, ANY, and NULL.
    NullBase    ::= { EVENT, REAL }.    
    TypeRel(s, t, EMPTY)    :- CompTypeRel(s, t), s = BaseType(ks), ks : NullBase, t = BaseType(kt), kt : NonNullBase.
    TypeRel(t, s, EMPTY)    :- CompTypeRel(t, s), s = BaseType(ks), ks : NullBase, t = BaseType(kt), kt : NonNullBase.
    
    TypeRel(s, t, EMPTY)    :- CompTypeRel(s, t), s = BaseType(ks), ks : NullBase, toSymbol(t) != #BaseType.
    TypeRel(t, s, EMPTY)    :- CompTypeRel(t, s), s = BaseType(ks), ks : NullBase, toSymbol(t) != #BaseType.
          
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = BaseType(ks), ks : NullBase, t = BaseType(kt), kt : NullBase, s != t, kt != ANY, kt != NULL.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = BaseType(ks), ks : NullBase, t = BaseType(kt), kt : NullBase, s != t, kt != ANY, kt != NULL.

    // Complex types have empty intersections with all differing type kinds, except ANY.
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s : ComplexType, toSymbol(s) != toSymbol(t), t != BaseType(ANY).
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), s : ComplexType, toSymbol(s) != toSymbol(t), t != BaseType(ANY).
    
    // Sequences are EMPTY or NONEMPTY if their inner types are. (Only need one version of these rules.)
    TypeRel(s, t, EMPTY)    :- CompTypeRel(s, t), s = SeqType(s'), t = SeqType(t'), TypeRel(s', t', EMPTY). 
    
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = SeqType(s'), t = SeqType(t'), TypeRel(s', t', NONEMPTY). 
    
    // Maps are EMPTY or NONEMPTY if their inner types are. (Only need one version of these rules.)
    TypeRel(s, t, EMPTY)    :- CompTypeRel(s, t), s = MapType(sd, _),  t = MapType(td, _),  TypeRel(sd, td, EMPTY).
    
    TypeRel(s, t, EMPTY)    :- CompTypeRel(s, t), s = MapType(_, sc),  t = MapType(_, tc),  TypeRel(sc, tc, EMPTY).    
    
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = MapType(sd, sc), t = MapType(td, tc), TypeRel(sd, td, NONEMPTY), TypeRel(sc, tc, NONEMPTY). 

    // Tuples and NmdTups are EMPTY if their lengths differ. (Only need one version of these rules.)
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s : TupType, t : TupType, lstLength(#TupType, s) != lstLength(#TupType, t).
    
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s : NmdTupType, t : NmdTupType, lstLength(#NmdTupType, s) != lstLength(#NmdTupType, t).
    
    // Tuples are EMPTY if any pair of inner types is EMPTY.  (Only need one version of some of these rules.)
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = TupType(s', _), t = TupType(t', _), TypeRel(s', t', EMPTY). 
    
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = TupType(_, s'), t = TupType(_, t'), TypeRel(s', t', EMPTY). 
    
    // Tuples are NONEMPTY if not all inners types are in identical super / sub relationships. 
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', NONEMPTY), TypeRel(s'', t'', r), r != EMPTY.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', NONEMPTY), TypeRel(s'', t'', r), r != EMPTY.
                                                                                           
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', r), TypeRel(s'', t'', NONEMPTY), r != EMPTY.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', r), TypeRel(s'', t'', NONEMPTY), r != EMPTY.

    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', SUB), TypeRel(s'', t'', SUP), s' != t', s'' != t''.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', SUB), TypeRel(s'', t'', SUP), s' != t', s'' != t''.
                               
    // Named Tuples are EMPTY if any pair of inner types is EMPTY or they name arguments differently. (Only need one version of some of these rules.) 
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = NmdTupType(fs, _), t = NmdTupType(ft, _), fs.name != ft.name. 
    
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = NmdTupType(fs, _), t = NmdTupType(ft, _), TypeRel(fs.type, ft.type, EMPTY). 
    
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = NmdTupType(_, s'), t = NmdTupType(_, t'), TypeRel(s', t', EMPTY). 
    
    // Named Tuples are NONEMPTY if not all inners types are in identical super / sub relationships. 
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, NONEMPTY), TypeRel(s'', t'', r), r != EMPTY.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, NONEMPTY), TypeRel(s'', t'', r), r != EMPTY.
                                                            
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, r), TypeRel(s'', t'', NONEMPTY), r != EMPTY.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, r), TypeRel(s'', t'', NONEMPTY), r != EMPTY.

    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, SUB), TypeRel(s'', t'', SUP), fs.type != ft.type, s'' != t''.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, SUB), TypeRel(s'', t'', SUP), fs.type != ft.type, s'' != t''.
                               
    //// (3) Sub-typing.                
    // Any non-ERROR type is sub-type related to itself.
    TypeRel(s, s, SUB) :- CompTypeRel(s, s), s != ERROR.
    TypeRel(s, s, SUP) :- CompTypeRel(s, s), s != ERROR.
   
    // Every proper type is a sub-type of any.
    TypeRel(s, t, SUB) :- CompTypeRel(s, t), s != ERROR, s != NIL, t = BaseType(ANY).
    TypeRel(t, s, SUP) :- CompTypeRel(t, s), s != ERROR, s != NIL, t = BaseType(ANY).
        
    // NULL is a subtype of all Nullable types.
    TypeRel(s, t, SUB) :- CompTypeRel(s, t), s = BaseType(NULL), t = BaseType(ANY).
    TypeRel(t, s, SUP) :- CompTypeRel(t, s), s = BaseType(NULL), t = BaseType(ANY).
    
    TypeRel(s, t, SUB) :-  CompTypeRel(s, t), s = BaseType(NULL), t = BaseType(kt), kt : NullBase.
    TypeRel(t, s, SUP) :-  CompTypeRel(t, s), s = BaseType(NULL), t = BaseType(kt), kt : NullBase.
    
    // Sequences are subtype related if their inner types are subtype related.
    TypeRel(s, t, SUB)    :- CompTypeRel(s, t), s = SeqType(s'), t = SeqType(t'), TypeRel(s', t', SUB). 
    TypeRel(s, t, SUP)    :- CompTypeRel(s, t), s = SeqType(s'), t = SeqType(t'), TypeRel(s', t', SUP). 
    
    // Maps are subtype related if their inner types are subtype related.
    TypeRel(s, t, SUB) :- CompTypeRel(s, t), s = MapType(sd, sc), t = MapType(td, tc), TypeRel(sd, td, SUB), TypeRel(sc, tc, SUB). 
    TypeRel(s, t, SUP) :- CompTypeRel(s, t), s = MapType(sd, sc), t = MapType(td, tc), TypeRel(sd, td, SUP), TypeRel(sc, tc, SUP). 
    
    // Tuples are subtype related if their inner types are subtype related.
    TypeRel(s, t, SUB) :- CompTypeRel(s, t), s = TupType(s', s''), t = TupType(t', t''), TypeRel(s', t', SUB), TypeRel(s'', t'', SUB).
    TypeRel(s, t, SUP) :- CompTypeRel(s, t), s = TupType(s', s''), t = TupType(t', t''), TypeRel(s', t', SUP), TypeRel(s'', t'', SUP).
    
    TypeRel(s, t, SUB) :- CompTypeRel(s, t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, TypeRel(fs.type, ft.type, SUB), TypeRel(s'', t'', SUB).    
    TypeRel(s, t, SUP) :- CompTypeRel(s, t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, TypeRel(fs.type, ft.type, SUP), TypeRel(s'', t'', SUP).   
	
    /*************************************************************/
    /*                      Payload Inference                    */
    /*************************************************************/	

	//// The type of a payload in some (anonymous) function is based on the events
	//// that could have lead to that execution of that function.
	PayloadType ::= (TypingContext, TypeExpr).

	PayloadType(plc, type) :- plc is PlContext, plc : TypingContext, 
	                          joins = toList(#TypeJoinList, NIL, 
	                          { t | TriggerSet(plc, DEFAULT), t = BaseType(NULL);
							        TriggerSet(plc, NEW),     t = BaseType(ANY);
									TriggerSet(plc, HALT),    t = BaseType(ANY);
									TriggerSet(plc, EXIT),    t = BaseType(ANY);
									TriggerSet(plc, e), EventDecl(e, _, t), t : TypeExpr;
									TriggerSet(plc, e), EventDecl(e, _, NIL), t = BaseType(NULL) }),
							  TypeJoins(joins, type).

	//// Need to record the set of events that could lead to the evaluation of a function.
	//// A default trigger, pushed state (via push statement), or intial state results in a null event.

	//// These are the places where payload can be written or read.
	PlContext ::= StateDecl + TransDecl + DoDecl + FunDecl + AnonFunDecl.

	//// The set of events that could have changed trigger and payload in this context.
	//// The NEW constant represents the new pseudo-event.
	TriggerSet ::= (cntxt: PlContext, name: String + { DEFAULT, HALT, NEW, EXIT }).
	
	//// (1) A transition's trigger set is a singleton containing the trigger.
	TriggerSet(t, t.trig) :- t is TransDecl. 

	//// (2) A do's trigger set is a singleton containing the trigger.
	TriggerSet(d, d.trig) :- d is DoDecl. 

	//// (3) A state's trigger set is the set of events that could have lead to this entry function.
	//// This state is an initial state, so give it the NEW pseudo-event.
	TriggerSet(s, NEW) :- m is MachineDecl, s is StateDecl, m.start = s.name, s.owner = m.

	//// This state is reached by a push statement, so give it the DEFAULT pseudo-event.
	TriggerSet(s, DEFAULT) :- SubSE(c, x), x = Push(name, _), s is StateDecl, s.owner = c.owner, s.name = name.

	//// This state can be reached by a transition, so give it the trigger of this transition.
	TriggerSet(s, t.trig) :- t is TransDecl, s is StateDecl, s.name = t.dst, s.owner = t.src.owner. 

	//// (4) An AnonFunDecl's trigger set is the set of events of its calling context.
	//// payloads in exit functions are unpredictable.
	//// (TODO: Must change AnonFunDecl's to capture different calling contexts.)
    TriggerSet(a, EXIT) :- s is StateDecl, a = s.exitFun, a : AnonFunDecl.
    TriggerSet(a, e)    :- TriggerSet(s, e), s : StateDecl, a = s.entryAction, a : AnonFunDecl.
    TriggerSet(a, e)    :- TriggerSet(t, e), t : TransDecl, a = t.action, a : AnonFunDecl.
    TriggerSet(a, e)    :- TriggerSet(d, e), d : DoDecl, a = d.action, a : AnonFunDecl.

	//// (5) An FunDecl's trigger set is the set of events of its calling contexts.
	//// payloads in exit functions are unpredictable.
    TriggerSet(f, EXIT) :- s is StateDecl, f is FunDecl, f.name = s.exitFun, f.owner = s.owner.
    TriggerSet(f, e)    :- TriggerSet(s, e), s : StateDecl, f is FunDecl, f.name = s.entryAction, f.owner = s.owner.
    TriggerSet(f, e)    :- TriggerSet(t, e), t : TransDecl, f is FunDecl, f.name = t.action, f.owner = t.src.owner.
    TriggerSet(f, e)    :- TriggerSet(d, e), d : DoDecl, f is FunDecl, f.name = d.action, f.owner = d.src.owner.

    TriggerSet(f, e) :- TriggerSet(c, e), SubSE(c, x), x = FunApp(name, _), f is FunDecl, f.owner = c.owner, f.name = name.
    TriggerSet(f, e) :- TriggerSet(c, e), SubSE(c, x), x = FunStmt(name, _), f is FunDecl, f.owner = c.owner, f.name = name.

    /*************************************************************/
    /*                      Compute type joins                   */
    /*************************************************************/	

	TypeJoinList ::= (TypeExpr, TypeJoinList + { NIL }). 

	//// The join of a pair of types and of a list of types.
	TypeJoin     ::= (ta: TypeExpr + { NIL }, tb: TypeExpr + { NIL }, j: TypeExpr + { NIL }).
    TypeJoins    ::= (list: TypeJoinList + { NIL }, type: TypeExpr).

	//// A pair of joins that need to be computed, and a list of joins that need to be computed.
	CompTypeJoin  ::= (TypeExpr + { NIL }, TypeExpr + { NIL }).
    CompTypeJoins ::= (list: TypeJoinList + { NIL }).

	//// Compute the type joins of payload contexts.
	CompTypeJoins(joins) :- plc is PlContext, 
	                        joins = toList(#TypeJoinList, NIL, 
	                          { t | TriggerSet(plc, DEFAULT), t = BaseType(NULL);
							        TriggerSet(plc, NEW),     t = BaseType(ANY);
									TriggerSet(plc, HALT),    t = BaseType(ANY);
									TriggerSet(plc, EXIT),    t = BaseType(ANY);
									TriggerSet(plc, e), EventDecl(e, _, t), t : TypeExpr;
									TriggerSet(plc, e), EventDecl(e, _, NIL), t = BaseType(NULL) }).

   //// Compute the joins of sub-lists
   CompTypeJoins(tail) :- CompTypeJoins(TypeJoinList(_, tail)).

   //// To compute the join of a longer list, must compute the binary join of head and joined sub-list.
   CompTypeJoin(hd, tj) :- CompTypeJoins(list), list = TypeJoinList(hd, tl), TypeJoins(tl, tj), tl : TypeJoinList.
   
   //// Once the binary join of head and tail are known, then the join of the list is known.   
   TypeJoins(list, j) :- CompTypeJoins(list), list = TypeJoinList(hd, tl), TypeJoins(tl, tj), TypeJoin(hd, tj, j), tl : TypeJoinList, j : TypeExpr.

   //// The join of a singleton list is the type in the list. 
   TypeJoins(list, t) :- CompTypeJoins(list), list = TypeJoinList(t, NIL).

   //// The join of the empty list is, by definition, the null type.
   TypeJoins(NIL, BaseType(NULL)).

   /*************************************************************/
   /*                      Binary type joins                    */
   /*************************************************************/	

    CompTypeJoin(ta', tb')                     :- CompTypeJoin(ta, tb), ta = SeqType(ta'), tb = SeqType(tb').    
    CompTypeJoin(da, db), CompTypeJoin(ca, cb) :- CompTypeJoin(ta, tb), ta = MapType(da, ca), tb = MapType(db, cb).
    CompTypeJoin(la, lb), CompTypeJoin(ra, rb) :- CompTypeJoin(ta, tb), ta = TupType(la, ra), tb = TupType(lb, rb).
    CompTypeJoin(la, lb), CompTypeJoin(ra, rb) :- CompTypeJoin(ta, tb), ta = NmdTupType(lfa, ra), tb = NmdTupType(lfb, rb), la = lfa.type, lb = lfb.type.

	//// (1) Handle NIL cases.
    TypeJoin(NIL, s, s) :- CompTypeJoin(NIL, s).
    TypeJoin(s, NIL, s) :- CompTypeJoin(s, NIL).

	//// (2) Join is idempotent 
    TypeJoin(s, s, s) :- CompTypeJoin(s, s).

    //// (3) Join of nullable types with null id null   
    TypeJoin(s, t, s) :- CompTypeJoin(s, t), s = BaseType(sk), sk : NullBase, t = BaseType(NULL). 
    TypeJoin(t, s, s) :- CompTypeJoin(t, s), s = BaseType(sk), sk : NullBase, t = BaseType(NULL). 

    //// (4) Join of sequence types. 
    TypeJoin(s, t, j) :- CompTypeJoin(s, t), s = SeqType(snr), t = SeqType(tnr), TypeJoin(snr, tnr, jnr), j = SeqType(jnr).

    //// (5) Join of map types. 
    TypeJoin(s, t, j) :- CompTypeJoin(s, t), s = MapType(sd, sc), t = MapType(td, tc), TypeJoin(sd, td, jd), TypeJoin(sc, tc, jc), j = MapType(jd, jc).

    //// (6) Join of tup types. 
    TypeJoin(s, t, j) :- CompTypeJoin(s, t), s = TupType(sh, st), t = TupType(th, tt), lstLength(#TupType, st) = lstLength(#TupType, tt), 
	                     TypeJoin(sh, th, jh), TypeJoin(st, tt, jt), j = TupType(jh, jt).

    //// (7) Join of named tup types. 
	//// If the tail of the named tuple is NIL, then the named tuple can be joined.
    TypeJoin(s, t, j) :- CompTypeJoin(s, t), s = NmdTupType(sh, NIL), t = NmdTupType(th, NIL),  
	                     TypeJoin(sh.type, th.type, jh), sh.name = th.name, j = NmdTupType(NmdTupTypeField(sh.name, jh), NIL).

	//// Otherwise, the tail must be joinable to a named tuple for the tuple to be joined
    TypeJoin(s, t, j) :- CompTypeJoin(s, t), s = NmdTupType(sh, st), t = NmdTupType(th, tt), 
	                     TypeJoin(sh.type, th.type, jh), sh.name = th.name, TypeJoin(st, tt, jt), 
						 st: NmdTupType, tt : NmdTupType, jt : NmdTupType,						 
						 j = NmdTupType(NmdTupTypeField(sh.name, jh), jt).

    //// (8) Remaining cases join to ANY. 
	NonNullAny ::= NonNullBase + { ANY }.

    TypeJoin(s, t, BaseType(ANY)) :- CompTypeJoin(s, t), toSymbol(s) != toSymbol(t), s : TypeExpr, t : TypeExpr.

    TypeJoin(s, t, BaseType(ANY)) :- CompTypeJoin(s, t), s != t, s = BaseType(sk), t = BaseType(tk), sk != NULL, tk != NULL. 

    TypeJoin(s, t, BaseType(ANY)) :- CompTypeJoin(s, t), s = BaseType(NULL), t = BaseType(tk), tk : NonNullAny. 
    TypeJoin(t, s, BaseType(ANY)) :- CompTypeJoin(t, s), s = BaseType(NULL), t = BaseType(tk), tk : NonNullAny. 

    TypeJoin(s, t, BaseType(ANY)) :- CompTypeJoin(s, t), s : TupType, t : TupType, lstLength(#TupType, s) != lstLength(#TupType, t).

    TypeJoin(s, t, BaseType(ANY)) :- CompTypeJoin(s, t), s : NmdTupType, t : NmdTupType, lstLength(#NmdTupType, s) != lstLength(#NmdTupType, t).
    TypeJoin(s, t, BaseType(ANY)) :- CompTypeJoin(s, t), s : NmdTupType, t : NmdTupType, s.hd.name != t.hd.name.
    TypeJoin(s, t, BaseType(ANY)) :- CompTypeJoin(s, t), s = NmdTupType(_, st), t = NmdTupType(_, tt), TypeJoin(st, tt, jt), 
						             st: NmdTupType, tt : NmdTupType, toSymbol(jt) != #NmdTupType.
 }