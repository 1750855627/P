domain P extends PStaticTyping, PStructuralTyping
{

}

domain PData
{        
    /*************************************************************/
    /****************          Type Language          ************/
    /*************************************************************/    
       
    //// The BaseType REAL is the type of real machines.
    BaseType        ::= new ({ NULL, BOOL, INT, EVENT, REAL, MODEL, FOREIGN, ANY }).
    TupType         ::= new (hd: any TypeExpr, tl: any TupType + { NIL }).
    NmdTupType      ::= new (hd: any NmdTupTypeField, tl: any NmdTupType + { NIL }).
    SeqType         ::= new (x: any TypeExpr).
    MapType         ::= new (k: any TypeExpr, v: any TypeExpr).
    NmdTupTypeField ::= new (name: any String, type: any TypeExpr). 
    TypeExpr        ::= BaseType + TupType + NmdTupType + SeqType + MapType.
        
    /*************************************************************/
    /****************          Action Language        ************/
    /*************************************************************/    
                               
    //// Expressions
    Name       ::= new (name: String).
    New        ::= new (name: String, arg: any Expr + { NIL }).
    FunApp     ::= new (name: String, args: any Exprs + { NIL }).
    NulApp     ::= new (op: Integer + Boolean + { THIS, TRIGGER, PAYLOAD, NONDET, FAIRNONDET, NULL, HALT }).
    UnApp      ::= new (op: { NOT, NEG, KEYS, VALUES, SIZEOF }, arg1: any Expr).
    BinApp     ::= new (op: { ADD, SUB, MUL, INTDIV, AND, OR, EQ, NEQ, LT, LE, GT, GE, IDX, IN }, arg1: any Expr, arg2: any Expr).
    Field      ::= new (arg: any Expr, name: String + Natural).
    Default    ::= new (type: any TypeExpr). 
    Cast       ::= new (arg: any Expr, type: any TypeExpr). 
    Tuple      ::= new (body: any Exprs).
    NamedTuple ::= new (body: any NamedExprs).
    Exprs      ::= new (head: any Expr, tail: any Exprs + { NIL }).              
    NamedExprs ::= new (field: String, exp: any Expr, tail: any NamedExprs + { NIL }).
    Expr       ::= Name + New + FunApp + NulApp + UnApp + BinApp + Field + Default + Cast + Tuple + NamedTuple.
    ExprsExt   ::= Expr + Exprs + NamedExprs.

    //// Statements
    Push     ::= new (name: any QualifiedName).
    NewStmt  ::= new (name: String, arg: any Expr + { NIL }).
    Raise    ::= new (ev: any Expr, arg: any Expr + { NIL }).
    Send     ::= new (dest: any Expr, ev: any Expr, arg: any Expr + { NIL }).
    Monitor  ::= new (name: String, ev: Expr, arg: Expr + { NIL }).
    FunStmt  ::= new (name: String, args: any Exprs + { NIL }).
    NulStmt  ::= new (op: { SKIP, POP }).
    UnStmt   ::= new (op: { ASSERT }, arg1: any Expr).
    BinStmt  ::= new (op: { REMOVE, ASSIGN, INSERT }, arg1: any Expr, arg2: any Expr).
    Return   ::= new (expr: any Expr + { NIL }).
    While    ::= new (cond: any Expr, body: any Stmt).
    Ite      ::= new (cond: any Expr, true: any Stmt, false: any Stmt).
    Seq      ::= new (s1: any Stmt, s2: any Stmt).

    Stmt ::= Push + NewStmt + Raise + Send + Monitor + FunStmt + NulStmt + UnStmt + BinStmt + Return + While + Ite + Seq. 

    /*************************************************************/
    /****************  State Machine Declarations    *************/
    /*************************************************************/

    EventDecl      ::= fun (name: String -> card: any QueueConstraint, type: any TypeExpr + { NIL }).    
    MachineDecl    ::= fun (name: String -> kind: { REAL, MODEL, MONITOR }, card: any QueueConstraint, start: any QualifiedName, isMain: Boolean).
    VarDecl        ::= fun (name: String, owner: MachineDecl -> type: any TypeExpr).
    
    FunDecl        ::= fun (name: String, owner: MachineDecl -> kind: { REAL, MODEL }, params: any NmdTupType + { NIL },  return: any TypeExpr + { NIL }, body: any Stmt).
    AnonFunDecl    ::= new (owner: MachineDecl, body: any Stmt).
    ActionDecl     ::= fun (name: String, owner: MachineDecl -> body: any Stmt).
    AnonActionDecl ::= new (owner: MachineDecl, body: any Stmt).
    
    StateDecl      ::= fun (name: any QualifiedName, owner: MachineDecl -> entryAction: any AnonActionDecl + String, exitFun: any AnonFunDecl + String, isStable: Boolean).
    TransDecl      ::= fun (src: StateDecl, trig: String + { DEFAULT, HALT } -> dst: any QualifiedName, action: any { NIL, PUSH } + AnonFunDecl + String).
    DoDecl         ::= fun (src: StateDecl, trig: String + { HALT } -> action: any { DEFER, IGNORE } + AnonActionDecl + String).
            
    AssumeMaxInstances ::= new (bound: Natural).
    AssertMaxInstances ::= new (bound: Natural).
    QualifiedName      ::= new (name: String, qualifier: any QualifiedName + { NIL }).
    QueueConstraint    ::= AssumeMaxInstances + AssertMaxInstances + { NIL }.
    EventLabel         ::= String + { DEFAULT, HALT }.

    /*************************************************************/
    /****************          Annotations           *************/
    /*************************************************************/

    Annotation  ::= new (ant: Annotatable, key: String, value: any AnnotValue).
    Annotatable ::= EventDecl + MachineDecl + VarDecl + FunDecl + ActionDecl + StateDecl + TransDecl + DoDecl + { NIL }.
    AnnotValue  ::= Integer + String + Boolean + { NULL }.
}

domain PStructuralTyping extends PData
{
	////// Duplicate Declarations 
    DuplicateEvent ::= (EventDecl, EventDecl).
	DuplicateState ::= (StateDecl, StateDecl).
	DuplicateFunct ::= (FunDecl, FunDecl).
	DuplicateTransDecl ::= (TransDecl, TransDecl).
	DuplicateDoDecl ::= (DoDecl, DoDecl).
	DuplicateVarDecl ::= (VarDecl, VarDecl).
	DuplicateMacDecl ::= (MachineDecl, MachineDecl).
	DuplicateAction ::= (ActionDecl, ActionDecl).
	
	[ rule_Classes = '"error, msg: An event has multiple definitions"']
	DuplicateEvent(e1, e2) :- e1 is EventDecl, e2 is EventDecl, e1.name = e2.name, e1 != e2.
	[ rule_Classes = '"error, msg: Multiple states with the same name"']
	DuplicateState(s1, s2) :- s1 != s2, s1 is StateDecl, s2 is StateDecl, s1.name = s2.name, s1.owner = s2.owner.
	[ rule_Classes = '"error, msg: Multiple Functions with the same name"']
	DuplicateFunct(f1, f2) :- f1 != f2, f1 is FunDecl, f2 is FunDecl, f1.name = f2.name, f1.owner = f2.owner.
	[ rule_Classes = '"error, msg: Multiple actions with the same name"']
	DuplicateAction(f1, f2) :- f1 != f2, f1 is ActionDecl, f2 is ActionDecl, f1.name = f2.name, f1.owner = f2.owner.
	[ rule_Classes = '"error, msg: Multiple variables with the same name"']
	DuplicateVarDecl(v1, v2) :- v1 != v2, v1 is VarDecl, v2 is VarDecl, v1.name = v2.name, v1.owner = v2.owner.
	[ rule_Classes = '"error, msg: Multiple machines with the same name"']
	DuplicateMacDecl(m1, m2) :- m1 != m2, m1 is MachineDecl, m2 is MachineDecl, m1.name = m2.name.
	[ rule_Classes = '"error, msg: Multiple Transitions over the same event"']
	DuplicateTransDecl(t1, t2) :- t1 != t2, t1 is TransDecl, t2 is TransDecl, t1.src = t2.src, t1.trig = t2.trig.
	[ rule_Classes = '"error, msg: Multiple actions over the same event"']
	DuplicateDoDecl(a1, a2) :- a1 != a2, a1 is DoDecl(state, owner, _), a2 is DoDecl(state, owner, _), a1.src = a2.src, a1.trig = a2.trig.
	
	
	//// There should be a main machine
	[rule_Classes = '"error, msg: No Main Machine"']
	noMainMachine :- no MachineDecl(_, _, _, _, TRUE).
	multipleMainMachines ::= (MachineDecl, MachineDecl).
	[ rule_Classes = '"error, msg: Multiple machines are declared as main machines"']
	multipleMainMachines(m1, m2) :- m1 is MachineDecl, m2 is MachineDecl, m1.isMain = TRUE, m2.isMain = TRUE, m1 != m2.
	
	//// there should be a start state in each state machine.
	noStartState ::= (MachineDecl).
	[ rule_Classes = '"error, msg: no start state in machine"']
	noStartState(m) :- m is MachineDecl, no StateDecl(s, m , _, _, _), m.start = s.
	
	//Valid TransDecl
	invalidEventOnTransDecl ::= (TransDecl).
	[ rule_Classes = '"error, msg: transition on an undefined event"']
	invalidEventOnTransDecl(trns) :- trns is TransDecl, no EventDecl(trns.trig, _, _), trns.trig != DEFAULT, trns.trig != HALT.
	
	//valid doDecl
	invalidEventOnDoDecl ::= (DoDecl).
	[ rule_Classes = '"error, msg: action on an undefined event"']
	invalidEventOnDoDecl(doD) :- doD is DoDecl, no EventDecl(doD.trig, _, _), doD.trig != HALT.
}

domain PStaticTyping extends PData
/*
[
    compiler_ProductivityCheck = "TypeOf[1]"
]
*/
{
    /*************************************************************/
	conforms no TypeOf(_, _, ERROR). 
	conforms no DupNmdSubE(_, _, _, _).
	conforms no PurityError(_, _).
	conforms no LValueError(_, _).
    /*************************************************************/

    //// The declarations that may contain expressions or statements that should be typed.
    TypingContext ::= FunDecl + ActionDecl + AnonFunDecl + AnonActionDecl.
    
    //// The set of typeable expressions and statements.
    Typeable ::= Expr + Stmt + Exprs + NamedExprs.
    
    //// The type judgement. NIL is a placeholder for untyped constructs.
    TypeOf ::= (cntxt: TypingContext, expr: Typeable, type: TypeExpr + { ERROR, NIL }).
    
    //// All typeable subexpressions / substatements and the declarations in which they appear.
    SubSE ::= sub (cntxt: TypingContext, typeable: Typeable).

    /*************************************************************/
    /*                      Types of Expressions                 */
    /*************************************************************/
    
    //// (1) The types of nullary expressions
    TypeOf(c, e, BaseType(NULL))  :- SubSE(c, e), e = NulApp(NULL).
    TypeOf(c, e, BaseType(EVENT)) :- SubSE(c, e), e = NulApp(TRIGGER).
    TypeOf(c, e, BaseType(EVENT)) :- SubSE(c, e), e = NulApp(HALT).
    TypeOf(c, e, BaseType(ANY))   :- SubSE(c, e), e = NulApp(PAYLOAD).
    
    TypeOf(c, e, BaseType(REAL))  :- SubSE(c, e), e = NulApp(THIS), c.owner.kind = REAL.
    TypeOf(c, e, BaseType(MODEL)) :- SubSE(c, e), e = NulApp(THIS), c.owner.kind = MODEL.
	[ rule_Classes = '"error, msg: Monitors cannot refer to "this""']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = NulApp(THIS), c.owner.kind = MONITOR.
    
    TypeOf(c, e, BaseType(BOOL))  :- SubSE(c, e), e = NulApp(NONDET), c.owner.kind != REAL.
	[ rule_Classes = '"error, msg: Nonderminitistic choice cannot be used in real machines"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = NulApp(NONDET), c.owner.kind = REAL.

    TypeOf(c, e, BaseType(BOOL))  :- SubSE(c, e), e = NulApp(FAIRNONDET), c.owner.kind != REAL.
	[ rule_Classes = '"error, msg: Nonderminitistic choice cannot be used in real machines"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = NulApp(FAIRNONDET), c.owner.kind = REAL.
    
    TypeOf(c, e, BaseType(INT))   :- SubSE(c, e), e = NulApp(v), v : Integer.
    TypeOf(c, e, BaseType(BOOL))  :- SubSE(c, e), e = NulApp(v), v : Boolean.          
    
    //// (2) The types of unary expressions
    TypeOf(c, e, t)               :- SubSE(c, e), e = Default(t). 
    
    TypeOf(c, e, t)               :- SubSE(c, e), e = Tuple(e'), TypeOf(c, e', t).
     
    TypeOf(c, e, t)               :- SubSE(c, e), e = NamedTuple(e'), TypeOf(c, e', t).     

    // Variables hide the names of events, in case both have the same name.
	TypeOf(c, e, t)	              :- SubSE(c, e), e = Name(n), TypeOfFormalParam(c, n, t).
    TypeOf(c, e, t)               :- SubSE(c, e), e = Name(n), VarDecl(n, c.owner, t), no TypeOfFormalParam(c, n, _). 
    TypeOf(c, e, BaseType(EVENT)) :- SubSE(c, e), e = Name(n), EventDecl(n, _, _), no VarDecl(n, c.owner, _), no TypeOfFormalParam(c, n, _). 
	[ rule_Classes = '"error, msg: Undefined symbol"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = Name(n), no EventDecl(n, _, _), no VarDecl(n, c.owner, _), no TypeOfFormalParam(c, n, _). 
    
    TypeOf(c, e, BaseType(BOOL))  :- SubSE(c, e), e = UnApp(NOT, e'), TypeOf(c, e', BaseType(b)), b = BOOL. 
	[ rule_Classes = '"error, msg: Operator expected a boolean value"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = UnApp(NOT, e'), TypeOf(c, e', BaseType(b)), b != BOOL. 
    
    TypeOf(c, e, BaseType(INT))   :- SubSE(c, e), e = UnApp(NEG, e'), TypeOf(c, e', BaseType(b)), b = INT. 
	[ rule_Classes = '"error, msg: Operator expected an integer value"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = UnApp(NEG, e'), TypeOf(c, e', BaseType(b)), b != INT. 
    
    TypeOf(c, e, dom)             :- SubSE(c, e), e = UnApp(KEYS, e'), TypeOf(c, e', t), t = MapType(dom, cod). 
	[ rule_Classes = '"error, msg: Operator expected a map value"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = UnApp(KEYS, e'), TypeOf(c, e', t), toSymbol(t) != #MapType. 

    TypeOf(c, e, cod)             :- SubSE(c, e), e = UnApp(VALUES, e'), TypeOf(c, e', t), t = MapType(dom, cod). 
	[ rule_Classes = '"error, msg: Operator expected a map value"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = UnApp(VALUES, e'), TypeOf(c, e', t), toSymbol(t) != #MapType. 

    TypeOf(c, e, BaseType(INT))   :- SubSE(c, e), e = UnApp(SIZEOF, e'), TypeOf(c, e', t), t : MapType. 
    TypeOf(c, e, BaseType(INT))   :- SubSE(c, e), e = UnApp(SIZEOF, e'), TypeOf(c, e', t), t : SeqType. 
	[ rule_Classes = '"error, msg: Operator expected a map or sequence value"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = UnApp(SIZEOF, e'), TypeOf(c, e', t), toSymbol(t) != #MapType, toSymbol(t) != #SeqType. 
    
    //// (3) The types of binary expressions
    TypeOf(c, e, t)                :- SubSE(c, e), e = Cast(e', t), TypeOf(c, e', t'), TypeRel(t, t', k), k != EMPTY.
	[ rule_Classes = '"error, msg: Cast can never succeed"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Cast(e', t), TypeOf(c, e', t'), TypeRel(t, t', k), k = EMPTY.

    TypeOf(c, e, BaseType(REAL))   :- SubSE(c, e), e = New(n, _), MachineDecl(n, REAL, _, _, _).
    TypeOf(c, e, BaseType(MODEL))  :- SubSE(c, e), e = New(n, _), MachineDecl(n, MODEL, _, _, _).
	[ rule_Classes = '"error, msg: Monitors cannot be created with "new""']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = New(n, _), MachineDecl(n, MONITOR, _, _, _).
	[ rule_Classes = '"error, msg: Undefined machine type"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = New(n, _), no MachineDecl(n, _, _, _, _).   
    
    TypeOf(c, e, ft)               :- SubSE(c, e), e = Field(e', n), TypeOf(c, e', t), TypeOfField(t, n, ft), ft != ERROR.
	[ rule_Classes = '"error, msg: Bad field name"']
    TypeOf(c, e, ft)               :- SubSE(c, e), e = Field(e', n), TypeOf(c, e', t), TypeOfField(t, n, ft), ft = ERROR.
	[ rule_Classes = '"error, msg: Operator expected a (named) tuple value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Field(e', n), TypeOf(c, e', t), toSymbol(t) != #TupType, toSymbol(t) != #NmdTupType.
    
    PureIntOp ::= { ADD, SUB, MUL, INTDIV }.
    TypeOf(c, e, bint)             :- SubSE(c, e), e = BinApp(op, e', e''), TypeOf(c, e', bint), TypeOf(c, e'', bint), op : PureIntOp, bint = BaseType(INT).
	[ rule_Classes = '"error, msg: Operator expected first argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, e', _), TypeOf(c, e', t), op : PureIntOp, t != BaseType(INT).    
	[ rule_Classes = '"error, msg: Operator expected second argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, _, e''), TypeOf(c, e'', t), op : PureIntOp, t != BaseType(INT).    
    
    PureIntRel ::= { LT, LE, GT, GE }.
    TypeOf(c, e, BaseType(BOOL))   :- SubSE(c, e), e = BinApp(op, e', e''), TypeOf(c, e', bint), TypeOf(c, e'', bint), op : PureIntRel, bint = BaseType(INT).
	[ rule_Classes = '"error, msg: Operator expected first argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, e', _), TypeOf(c, e', t), op : PureIntRel, t != BaseType(INT).    
	[ rule_Classes = '"error, msg: Operator expected second argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, _, e''), TypeOf(c, e'', t), op : PureIntRel, t != BaseType(INT).    
    
    PureBoolOp ::= { AND, OR }.
    TypeOf(c, e, BaseType(BOOL))   :- SubSE(c, e), e = BinApp(op, e', e''), TypeOf(c, e', bbool), TypeOf(c, e'', bbool), op : PureBoolOp, bbool = BaseType(BOOL).
	[ rule_Classes = '"error, msg: Operator expected first argument to be a boolean value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, e', _), TypeOf(c, e', t), op : PureBoolOp, t != BaseType(BOOL).    
	[ rule_Classes = '"error, msg: Operator expected second argument to be a boolean value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, _, e''), TypeOf(c, e'', t), op : PureBoolOp, t != BaseType(BOOL).    
    
    PolyRel ::= { EQ, NEQ }.
    TypeOf(c, e, BaseType(BOOL))   :- SubSE(c, e), e = BinApp(op, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), op : PolyRel, TypeRel(t', t'', k), k != EMPTY.
	[ rule_Classes = '"error, msg: Values cannot be compared because their types are incompatible"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), op : PolyRel, TypeRel(t', t'', k), k = EMPTY.
    
    TypeOf(c, e, inner)            :- SubSE(c, e), e = BinApp(IDX, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' = SeqType(inner), t'' = BaseType(INT).
    TypeOf(c, e, cod)              :- SubSE(c, e), e = BinApp(IDX, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' = MapType(dom, cod), TypeRel(t'', dom, SUB).
	[ rule_Classes = '"error, msg: Indexer must be applied to a sequence or map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(IDX, e', _), TypeOf(c, e', t'), toSymbol(t') != #SeqType, toSymbol(t') != #MapType.
	[ rule_Classes = '"error, msg: Index must be an integer"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(IDX, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' : SeqType, t'' != BaseType(INT).
	[ rule_Classes = '"error, msg: Index may not be in the domain of the map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(IDX, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' = MapType(dom, _), TypeRel(t'', dom, k), t'' != dom, k != SUB.
    
    TypeOf(c, e, BaseType(BOOL))   :- SubSE(c, e), e = BinApp(IN, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t'' = SeqType(inner), TypeRel(t', inner, k), k != EMPTY.
    TypeOf(c, e, BaseType(BOOL))   :- SubSE(c, e), e = BinApp(IN, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t'' = MapType(dom, _), TypeRel(t', dom, k), k != EMPTY.        
	[ rule_Classes = '"error, msg: Value can never be in the sequence"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(IN, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t'' = SeqType(inner), TypeRel(t', inner, EMPTY).
	[ rule_Classes = '"error, msg: Value can never be in the map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(IN, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t'' = MapType(dom, _), TypeRel(t', dom, EMPTY).        
	[ rule_Classes = '"error, msg: "in" expects a sequence or map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(IN, _, e''),  TypeOf(c, e'', t''), toSymbol(t'') != #SeqType, toSymbol(t'') != #MapType.
    
	///// (4) Exprs produces a tuple type
	TypeOf(c, e, t) :- SubSE(c, e), e = Exprs(e', NIL), TypeOf(c, e', t'), t = TupType(t', NIL).
	TypeOf(c, e, t) :- SubSE(c, e), e = Exprs(e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t'' : TupType, t = TupType(t', t'').
		
	//// (5) NamedExprs produces a named tuple type.
	TypeOf(c, e, t) :- SubSE(c, e), e = NamedExprs(n', e', NIL), TypeOf(c, e', t'), t = NmdTupType(NmdTupTypeField(n', t'), NIL).
	TypeOf(c, e, t) :- SubSE(c, e), e = NamedExprs(n', e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t'' : NmdTupType, t = NmdTupType(NmdTupTypeField(n', t'), t'').
	
	//// (6) FunApps must refer to a defined function that has a non-NIL return type and args must be sub-types of function signature. 
	TypeOf(c, e, t)     :- SubSE(c, e), e = FunApp(n, NIL), FunDecl(n, c.owner, _, NIL, t, _), t != NIL.
	TypeOf(c, e, t)     :- SubSE(c, e), e = FunApp(n, e'), TypeOf(c, e', argt), decl is FunDecl(n, c.owner, _, _, t, _), FuncSigTupleType(decl, inpt), TypeRel(argt, inpt, SUB), t != NIL.

	[ rule_Classes = '"error, msg: function not defined"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, _), no FunDecl(n, c.owner, _, _, _, _).	
	[ rule_Classes = '"error, msg: function does not return a value"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, _), FunDecl(n, c.owner, _, _, NIL, _).
	[ rule_Classes = '"error, msg: function requires arguments"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, NIL), FunDecl(n, c.owner, _, params, _, _), params != NIL.
	[ rule_Classes = '"error, msg: function arguments have incorrect types"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, e'), TypeOf(c, e', argt), decl is FunDecl(n, c.owner, _, _, _, _), FuncSigTupleType(decl, inpt), TypeRel(argt, inpt, k), argt != inpt, k != SUB.
	
    /*************************************************************/
    /*                      Types of Statements                  */
    /*************************************************************/

	//// (1) Nullary statements
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = NulStmt(SKIP).

    TypeOf(c, e, NIL)              :- SubSE(c, e), e = NulStmt(POP), c : ActionDecl.
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = NulStmt(POP), c : AnonActionDecl.
	[ rule_Classes = '"error, msg: "pop" can only appear in an action."']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = NulStmt(POP), toSymbol(c) != #ActionDecl, toSymbol(c) != #AnonActionDecl.

	//// (2) Return statement
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Return(NIL), c = FunDecl(_, _, _, _, NIL, _). 
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Return(e'), c = FunDecl(_, _, _, _, t, _), TypeOf(c, e', t'), TypeRel(t', t, SUB).
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Return(NIL), toSymbol(c) != #FunDecl. 
	[ rule_Classes = '"error, msg: function must return a value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Return(NIL), c = FunDecl(_, _, _, _, t, _), t != NIL. 
	[ rule_Classes = '"error, msg: return value has incorrect type"' ]
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Return(e'), c = FunDecl(_, _, _, _, t, _), TypeOf(c, e', t'), TypeRel(t', t, k), t' != t, k != SUB.
	[ rule_Classes = '"error, msg: return cannot return a value here"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Return(t), toSymbol(c) != #FunDecl, t != NIL. 

	//// (3) Non-mutating statements
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Seq(_, _).
    
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = UnStmt(ASSERT, e'), TypeOf(c, e', t'), t' = BaseType(BOOL).
	[ rule_Classes = '"error, msg: "assert" expects a boolean value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = UnStmt(ASSERT, e'), TypeOf(c, e', t'), t' != BaseType(BOOL).
    
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Ite(e', _, _), TypeOf(c, e', t'), t' = BaseType(BOOL).
	[ rule_Classes = '"error, msg: "if (...)" expects a boolean value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Ite(e', _, _), TypeOf(c, e', t'), t' != BaseType(BOOL).
    
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = While(e', _), TypeOf(c, e', t'), t' = BaseType(BOOL).
	[ rule_Classes = '"error, msg: "while (...)" expects a boolean value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = While(e', _), TypeOf(c, e', t'), t' != BaseType(BOOL).
               
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Push(name), StateDecl(name, c.owner, _, _, _), c : ActionDecl. 
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Push(name), StateDecl(name, c.owner, _, _, _), c : AnonActionDecl. 
	[ rule_Classes = '"error, msg: Undeclared state name"']
	TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Push(name), no StateDecl(name, c.owner, _, _, _). 
	[ rule_Classes = '"error, msg: "push" can only appear in an action"']
	TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Push(_), toSymbol(c) != #ActionDecl, toSymbol(c) != #AnonActionDecl. 
    
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = NewStmt(n, _), MachineDecl(n, _, _, _, _).   
	[ rule_Classes = '"error, msg: Undeclared machine"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = NewStmt(n, _), no MachineDecl(n, _, _, _, _).   
    
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Raise(e', _), TypeOf(c, e', t'), t' = BaseType(EVENT), c : ActionDecl.   
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Raise(e', _), TypeOf(c, e', t'), t' = BaseType(EVENT), c : AnonActionDecl.   
	[ rule_Classes = '"error, msg: "raise" expects an event value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Raise(e', _), TypeOf(c, e', t'), t' != BaseType(EVENT).      
	[ rule_Classes = '"error, msg: "raise" can only appear in an action"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Raise(_, _), toSymbol(c) != #ActionDecl, toSymbol(c) != #AnonActionDecl.      
      
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Send(e', e'', _), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' = BaseType(REAL), t'' = BaseType(EVENT).
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Send(e', e'', _), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' = BaseType(MODEL), t'' = BaseType(EVENT).
	[ rule_Classes = '"error, msg: argument 2 of "send" expects an event value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Send(e', e'', _), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' = BaseType(REAL), t'' != BaseType(EVENT).
	[ rule_Classes = '"error, msg: argument 2 of "send" expects an event value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Send(e', e'', _), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' = BaseType(MODEL), t'' != BaseType(EVENT).
	[ rule_Classes = '"error, msg: argument 1 of "send" expects a machine value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Send(e', _, _), TypeOf(c, e', t'), t' != BaseType(REAL), t' != BaseType(MODEL).
    
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Monitor(n, e', _), MachineDecl(n, MONITOR, _, _, _), TypeOf(c, e', t'), t' = BaseType(EVENT).
	[ rule_Classes = '"error, msg: Undeclared monitor"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Monitor(n, _, _), no MachineDecl(n, MONITOR, _, _, _).
	[ rule_Classes = '"error, msg: argument 2 of "monitor" expects an event value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Monitor(_, e', _), TypeOf(c, e', t'), t' != BaseType(EVENT).

	//// (4) Mutating statements		
	TypeOf(c, e, NIL)			   :- SubSE(c, e), e = BinStmt(ASSIGN, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), TypeRel(t2, t1, SUB).
	[ rule_Classes = '"error, msg: invalid assignment. right hand side is not a subtype of left hand side"']
	TypeOf(c, e , ERROR)		   :- SubSE(c, e), e = BinStmt(ASSIGN, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), TypeRel(t2, t1, k), k!= SUB, t1 != t2.
		
	TypeOf(c, e, NIL)			   :- SubSE(c, e), e = BinStmt(REMOVE, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 : SeqType, t2 = BaseType(INT).
	TypeOf(c, e, NIL)			   :- SubSE(c, e), e = BinStmt(REMOVE, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = MapType(dom, cod), TypeRel(t2, dom, SUB).	
	[ rule_Classes = '"error, msg: remove must be applied to a sequence or map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinStmt(REMOVE, e', _), TypeOf(c, e', t'), toSymbol(t') != #SeqType, toSymbol(t') != #MapType.
    [ rule_Classes = '"error, msg: index must be an integer"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinStmt(REMOVE, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' : SeqType, t'' != BaseType(INT).
	[ rule_Classes = '"error, msg: Index may not be in the domain of the map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinStmt(REMOVE, e', e''), TypeOf(c, e', t'), TypeOf(c, e'', t''), t' = MapType(dom, _), TypeRel(t'', dom, k), t'' != dom, k != SUB.
	
	
	TypeOf(c, e, NIL)			   :- SubSE(c, e), e = BinStmt(INSERT, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = SeqType(inner), t2 = TupType(BaseType(INT), TupType(value, NIL)), TypeRel(value, inner, SUB).
	TypeOf(c, e, NIL)			   :- SubSE(c, e), e = BinStmt(INSERT, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)), TypeRel(value, cod, SUB), TypeRel(key, dom, SUB).	
	[ rule_Classes = '"error, msg: insert must be applied to a sequence or a map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinStmt(INSERT, e', _), TypeOf(c, e', t'), toSymbol(t') != #SeqType, toSymbol(t') != #MapType.
	[ rule_Classes = '"error, msg: for insert right syntax is seq += (index value) or map += (key value)"']
	TypeOf(c, e, ERROR)			   :- SubSE(c, e), e = BinStmt(INSERT, _, arg2), TypeOf(c, arg2, t2), toSymbol(t2) != #TupType; 
	                                  SubSE(c, e), e = BinStmt(INSERT, _, arg2), TypeOf(c, arg2, t2), t2 : TupType, lstLength(#TupType, t2) != 2.
    [ rule_Classes = '"error, msg: key must be an integer"']
    TypeOf(c, e, ERROR)			   :- SubSE(c, e), e = BinStmt(INSERT, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = SeqType(inner), t2 = TupType(idx, TupType(value, NIL)), idx != BaseType(INT).	
    [ rule_Classes = '"error, msg: value must be a subtype of sequence type"']
    TypeOf(c, e, ERROR)			   :- SubSE(c, e), e = BinStmt(INSERT, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = SeqType(inner), t2 = TupType(idx, TupType(value, NIL)), TypeRel(value, inner, k), k != SUB, value != inner.	
	[ rule_Classes = '"error, msg: key not in the domain of the map"']
    TypeOf(c, e, ERROR)			   :- SubSE(c, e), e = BinStmt(INSERT, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)), TypeRel(key, dom, k), k != SUB, key != dom.	
	[ rule_Classes = '"error, msg: value not in the codomain of the map"']
    TypeOf(c, e, ERROR)			   :- SubSE(c, e), e = BinStmt(INSERT, arg1, arg2), TypeOf(c, arg1, t1), TypeOf(c, arg2, t2), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)), TypeRel(value, cod, k), k != SUB, value != cod.
	
	//// (5) Function statements
	TypeOf(c, e, NIL)   :- SubSE(c, e), e = FunStmt(n, NIL), FunDecl(n, c.owner, _, NIL, _, _).
	TypeOf(c, e, NIL)   :- SubSE(c, e), e = FunStmt(n, e'), TypeOf(c, e', argt), decl is FunDecl(n, c.owner, _, _, _, _), FuncSigTupleType(decl, inpt), TypeRel(argt, inpt, SUB).
	[ rule_Classes = '"error, msg: function not defined"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, _), no FunDecl(n, c.owner, _, _, _, _).	
	[ rule_Classes = '"error, msg: function requires arguments"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, NIL), FunDecl(n, c.owner, _, params, _, _), params != NIL.
	[ rule_Classes = '"error, msg: function arguments have incorrect types"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, e'), TypeOf(c, e', argt), decl is FunDecl(n, c.owner, _, _, _, _), FuncSigTupleType(decl, inpt), TypeRel(argt, inpt, k), argt != inpt, k != SUB.

    /*************************************************************/
    /*                      Field helpers                        */
    /*************************************************************/

	TOrNTType      ::= TupType + NmdTupType.
	FieldLabel     ::= String + Natural.
    TypeOfField    ::= (tupTyp: TOrNTType, lookup: FieldLabel, fieldType: TypeExpr + { ERROR }).    
    TypeOfFieldAux ::= (tupTyp: TOrNTType, lookup: FieldLabel, fieldType: TypeExpr + { ERROR }, pos: Natural, tail: TOrNTType + { NIL }).

    TypeOfFieldAux(ttup, n, ERROR, 0, ttup)  :- SubSE(c, e), e = Field(e', n), TypeOf(c, e', ttup), ttup : TOrNTType.    
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, ERROR, pos, aux), n = pos, pos' = pos + 1, aux = TupType(t, tl).
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, ERROR, pos, aux), n = pos, pos' = pos + 1, aux = NmdTupType(NmdTupTypeField(_, t), tl).
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, ERROR, pos, aux), pos' = pos + 1, aux = NmdTupType(NmdTupTypeField(n, t), tl).

    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, t, pos, aux), n != pos, pos' = pos + 1, aux = TupType(_, tl).
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, t, pos, aux), n != pos, n != fn, pos' = pos + 1, aux = NmdTupType(NmdTupTypeField(fn, _), tl).

    TypeOfField(ttup, n, ft)                 :- TypeOfFieldAux(ttup, n, ft, _, NIL).    
	TypeOfField(ttup, n, ERROR)              :- TypeOfFieldAux(ttup, n, ERROR, 0, ttup), n : String, ttup : TupType.

    /*************************************************************/
    /*                  Formal Parameter Types                   */
    /*************************************************************/
    TypeOfFormalParam    ::= (cntxt: FunDecl, name: String, type: TypeExpr + { ERROR }).
    TypeOfFormalParamAux ::= (cntxt: FunDecl, name: String, type: TypeExpr, aux: NmdTupType + { NIL }).

    TypeOfFormalParamAux(cntxt, name, type, tl) :- cntxt is FunDecl(_, _, _, params, _, _), params = NmdTupType(NmdTupTypeField(name, type), tl).  
    TypeOfFormalParamAux(cntxt, name, type, tl) :- TypeOfFormalParamAux(cntxt, _, _, aux), aux = NmdTupType(NmdTupTypeField(name, type), tl).
    
    TypeOfFormalParam(cntxt, name, type)  :- TypeOfFormalParamAux(cntxt, name, type, aux), no { aux' | TypeOfFormalParamAux(cntxt, name, _, aux'), aux != aux' }.      
	//// This error is generated as part of DupNmdSubE
    TypeOfFormalParam(cntxt, name, ERROR) :- TypeOfFormalParamAux(cntxt, name, _, aux), TypeOfFormalParamAux(cntxt, name, _, aux'), aux != aux'.

	//// The input type of a function, ignoring names.
	FuncSigTupleType    ::= (cntxt: FunDecl, type: TupType + { NIL }).
	FuncSigTupleTypeAux ::= (cntxt: FunDecl, type: TupType + { NIL }, aux: NmdTupType + { NIL }).

	FuncSigTupleTypeAux(cntxt, params, NIL) :- cntxt is FunDecl(_, _, _, params, _, _), params = NIL.
	FuncSigTupleTypeAux(cntxt, type, tl)    :- cntxt is FunDecl(_, _, _, params, _, _), params = NmdTupType(NmdTupTypeField(_, t), tl), type = TupType(t, NIL).
	FuncSigTupleTypeAux(cntxt, type, tl)    :- FuncSigTupleTypeAux(cntxt, t', aux), aux = NmdTupType(NmdTupTypeField(_, t), tl), type = TupType(t, t').
	FuncSigTupleType(cntxt, t)              :- FuncSigTupleTypeAux(cntxt, t, NIL), type = lstReverse(#TupType, t).

    /*************************************************************/
    /* Check that named tuple (types) don't reuse the same name  */
    /*************************************************************/
	NmdList       ::= NmdTupType + NamedExprs.
	NmdListOrNone ::= NmdTupType + NamedExprs + { NIL }.

	NmdSubE     ::= sub (NmdList).
	MaxNmdSubE  ::=     (NmdList).
	NmdSubNames ::=     (list: NmdList, name: String, aux: NmdListOrNone). 
	DupNmdSubE  ::=     (list: NmdList, name: String, aux1: NmdListOrNone, aux2: NmdListOrNone).

	MaxNmdSubE(e) :- NmdSubE(e), no NmdSubE(NmdTupType(_, e)), no NmdSubE(NamedExprs(_, _, e)).
	NmdSubNames(list, name, tl) :- MaxNmdSubE(list), list = NmdTupType(NmdTupTypeField(name, _), tl). 
	NmdSubNames(list, name, tl) :- MaxNmdSubE(list), list = NamedExprs(name, _, tl). 
	NmdSubNames(list, name, tl) :- NmdSubNames(list, _, aux), aux = NmdTupType(NmdTupTypeField(name, _), tl). 
	NmdSubNames(list, name, tl) :- NmdSubNames(list, _, aux), aux = NamedExprs(name, _, tl). 

    [ rule_Classes = '"error, msg: same name appears more than once in name tuple or named tuple type"']
	DupNmdSubE(list, name, tl, tl') :- NmdSubNames(list, name, tl), NmdSubNames(list, name, tl'), tl != tl'.

    /*************************************************************/
    /*                          L-values                         */
    /*************************************************************/
	LValueError    ::= (cntxt: TypingContext, stmt: BinStmt).
	BinStmtSubExpr ::= sub (cntxt: TypingContext, stmt: BinStmt, expr: Expr).
	IsLValue       ::=     (cntxt: TypingContext, expr: Expr). 		
    IsLValue(c, e)  :- BinStmtSubExpr(c, _, e), e = Name(n), VarDecl(n, c.owner, t), no TypeOfFormalParam(c, n, _). 
    IsLValue(c, e)  :- BinStmtSubExpr(c, _, e), e = Field(e', _), IsLValue(c, e'). 
    IsLValue(c, e)  :- BinStmtSubExpr(c, _, e), e = BinApp(IDX, e', _), IsLValue(c, e'). 

    [ rule_Classes = '"error, msg: invalid LHS; must have the form LHS ::= var | LHS[expr] | LHS.name"']
	LValueError(c, e) :- SubSE(c, e), e = BinStmt(_, e', _), no IsLValue(c, e').
    /*************************************************************/
    /*                         Impurity                          */
    /*************************************************************/
	Impure      ::= (FunDecl).
    PurityError ::= (cntxt: TypingContext, expr: Typeable).

	Impure(c) :- SubSE(c, e), c : FunDecl, e : BinStmt.
	Impure(c) :- SubSE(c, e), e = FunApp(n, _), c : FunDecl, called is FunDecl(n, c.owner, _, _, _, _), Impure(called).
	Impure(c) :- SubSE(c, e), e = FunStmt(n, _), c : FunDecl, called is FunDecl(n, c.owner, _, _, _, _), Impure(called).

    [ rule_Classes = '"error, msg: this function must be pure. Impure functions can only be called like "foo(...);" or "x = foo(...);" "']
    PurityError(c, e') :- 
       SubSE(c, e), e = New(_, e'),           e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);
       SubSE(c, e), e = UnApp(_, e'),         e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);
       SubSE(c, e), e = BinApp(_, e', _),     e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);
       SubSE(c, e), e = BinApp(_, _, e'),     e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);    
       SubSE(c, e), e = Field(e', _),         e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);
       SubSE(c, e), e = Cast(e', _),          e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);    
       SubSE(c, e), e = Exprs(e', _),         e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);              
       SubSE(c, e), e = NamedExprs(_, e', _), e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);
       SubSE(c, e), e = NewStmt(_, e'),       e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);
       SubSE(c, e), e = Raise(e', _),         e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);
       SubSE(c, e), e = Raise(_, e'),         e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);        
       SubSE(c, e), e = Send(e', _, _),       e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);
       SubSE(c, e), e = Send(_, e', _),       e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);
       SubSE(c, e), e = Send(_, _, e'),       e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);    
       SubSE(c, e), e = Monitor(_, e', _),    e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);
       SubSE(c, e), e = Monitor(_, _, e'),    e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);    
       SubSE(c, e), e = UnStmt(_, e'),        e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);
       SubSE(c, e), e = Return (e'),          e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);
       SubSE(c, e), e = While(e', _),         e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);
       SubSE(c, e), e = Ite(e', _, _),        e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);
       SubSE(c, e), e = BinStmt(_, e', _),    e' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called);
       SubSE(c, e), e = BinStmt(_, e', e''),  e'' = FunApp(n, _), called is FunDecl(n, c.owner, _, _, _, _), Impure(called), toSymbol(e') != #Name.
							                                          
    /*************************************************************/
    /*                      Type Comparability                   */
    /*************************************************************/
    //// TypeRel determines the relationship between types. 
    //// If types are not subtype related, then they can
    //// either have an empty (EMPTY) or nonempty (NONEMPTY) intersection. 
    TypeRel ::= (ta: TypeExpr + { ERROR, NIL }, 
                 tb: TypeExpr + { ERROR, NIL }, 
                 rel: { SUB, SUP, EMPTY, NONEMPTY }).
    
    //// (1) The set of all computed type expressions (plus base types).
    TypeSub ::= (TypeExpr + { NIL, ERROR }).
    
    TypeSub(NIL).
    TypeSub(ERROR).
    TypeSub(base)          :- base = BaseType(NULL).
    TypeSub(base)          :- base = BaseType(BOOL).
    TypeSub(base)          :- base = BaseType(INT).
    TypeSub(base)          :- base = BaseType(EVENT).
    TypeSub(base)          :- base = BaseType(REAL).
    TypeSub(base)          :- base = BaseType(MODEL).
    TypeSub(base)          :- base = BaseType(FOREIGN).
    TypeSub(base)          :- base = BaseType(ANY).

    TypeSub(t)             :- TypeOf(_, _, t).
	TypeSub(t)             :- TypeOfFormalParam(_, _, t).
    TypeSub(t)             :- FuncSigTupleType(_, t).
    TypeSub(t)             :- TypeSub(s), s = SeqType(t).
    TypeSub(t), TypeSub(u) :- TypeSub(s), s = MapType(t, u).
    TypeSub(t), TypeSub(u) :- TypeSub(s), s = TupType(t, u), u : TypeExpr.
    TypeSub(t), TypeSub(u) :- TypeSub(s), s = NmdTupType(f, u), t = f.type, u : TypeExpr.
        
    //// (2) Type (non-) emptiness.    
    // Commutativity rule for the (non-) emptiness 
    TypeRel(t, s, EMPTY)    :- TypeRel(s, t, EMPTY).
    TypeRel(s, t, NONEMPTY) :- TypeRel(s, t, NONEMPTY).
    
    // For convenience, the ERROR type is incomparable to all types, even itself.
    TypeRel(ERROR, t, EMPTY) :- TypeSub(t).
    
    // For convenience, the NIL type is incomparable to all types, except itself.
    TypeRel(NIL, t, EMPTY) :- TypeSub(t), t != NIL.
    
    // The NULL type has empty intersections with NonNullBase and complex types.
    NonNullBase ::= { BOOL, INT, FOREIGN }.
    ComplexType ::= TupType  + NmdTupType + SeqType + MapType.
    TypeRel(null, t, EMPTY) :- TypeSub(t), t = BaseType(kt), kt : NonNullBase, null = BaseType(NULL).
    TypeRel(null, t, EMPTY) :- TypeSub(t), t : ComplexType, null = BaseType(NULL).
        
    // NonNullBase types have empty intersections with all types, except themselves and ANY.
    TypeRel(s, t, EMPTY) :- TypeSub(s), TypeSub(t), s = BaseType(ks), ks : NonNullBase, s != t, t != BaseType(ANY).

    // NullBase types have empty intersections with all types, except themselves, ANY, and NIL.
    NullBase    ::= { EVENT, REAL, MODEL }.
    TypeRel(s, t, EMPTY)    :- TypeSub(s), TypeSub(t), s = BaseType(ks), ks : NullBase, s != t, t != BaseType(ANY), t != BaseType(NULL).
    TypeRel(s, t, NONEMPTY) :- TypeSub(s), TypeSub(t), s = BaseType(ks), ks : NullBase, t = BaseType(kt), kt : NullBase, s != t.

    // Complex types have empty intersections with all differing type kinds, except ANY.
    TypeRel(s, t, EMPTY) :- TypeSub(s), TypeSub(t), s : ComplexType, toSymbol(s) != toSymbol(t), t != BaseType(ANY).
    
    // Sequences are EMPTY or NONEMPTY if their inner types are.
    TypeRel(s, t, EMPTY)    :- TypeSub(s), TypeSub(t), s = SeqType(s'), t = SeqType(t'), TypeRel(s', t', EMPTY). 
    TypeRel(s, t, NONEMPTY) :- TypeSub(s), TypeSub(t), s = SeqType(s'), t = SeqType(t'), TypeRel(s', t', NONEMPTY). 
    
    // Maps are EMPTY or NONEMPTY if their inner types are.
    TypeRel(s, t, EMPTY)    :- TypeSub(s), TypeSub(t), s = MapType(sd, _),  t = MapType(td, _),  TypeRel(sd, td, EMPTY).
    TypeRel(s, t, EMPTY)    :- TypeSub(s), TypeSub(t), s = MapType(_, sc),  t = MapType(_, tc),  TypeRel(sc, tc, EMPTY).    
    TypeRel(s, t, NONEMPTY) :- TypeSub(s), TypeSub(t), s = MapType(sd, sc), t = MapType(td, tc), TypeRel(sd, td, NONEMPTY), TypeRel(sc, tc, NONEMPTY). 

    // Tuples and NmdTups are EMPTY if their lengths differ.
    TypeRel(s, t, EMPTY) :- TypeSub(s), TypeSub(t), s : TupType, t : TupType, lstLength(#TupType, s) != lstLength(#TupType, t).
    TypeRel(s, t, EMPTY) :- TypeSub(s), TypeSub(t), s : NmdTupType, t : NmdTupType, lstLength(#NmdTupType, s) != lstLength(#NmdTupType, t).
    
    // Tuples are EMPTY if any pair of inner types is EMPTY. 
    // Tuples are NONEMPTY if not all inners types are in identical super / sub relationships. 
    TypeRel(s, t, EMPTY) :- TypeSub(s), TypeSub(t), s = TupType(s', _), t = TupType(t', _), TypeRel(s', t', EMPTY). 
    TypeRel(s, t, EMPTY) :- TypeSub(s), TypeSub(t), s = TupType(_, s'), t = TupType(_, t'), TypeRel(s', t', EMPTY). 
    
    TypeRel(s, t, NONEMPTY) :- TypeSub(s), TypeSub(t), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', NONEMPTY), TypeRel(s'', t'', r), r != EMPTY.
                                                            
    TypeRel(s, t, NONEMPTY) :- TypeSub(s), TypeSub(t), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', r), TypeRel(s'', t'', NONEMPTY), r != EMPTY.

    TypeRel(s, t, NONEMPTY) :- TypeSub(s), TypeSub(t), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', SUB), TypeRel(s'', t'', SUP), s' != t', s'' != t''.
                               
    // Named Tuples are EMPTY if any pair of inner types is EMPTY or they name arguments differently. 
    // Named Tuples are NONEMPTY if not all inners types are in identical super / sub relationships. 
    TypeRel(s, t, EMPTY) :- TypeSub(s), TypeSub(t), s = NmdTupType(fs, _), t = NmdTupType(ft, _), fs.name != ft.name. 
    TypeRel(s, t, EMPTY) :- TypeSub(s), TypeSub(t), s = NmdTupType(fs, _), t = NmdTupType(ft, _), TypeRel(fs.type, ft.type, EMPTY). 
    TypeRel(s, t, EMPTY) :- TypeSub(s), TypeSub(t), s = NmdTupType(_, s'), t = NmdTupType(_, t'), TypeRel(s', t', EMPTY). 
    
    TypeRel(s, t, NONEMPTY) :- TypeSub(s), TypeSub(t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, NONEMPTY), TypeRel(s'', t'', r), r != EMPTY.
                                                            
    TypeRel(s, t, NONEMPTY) :- TypeSub(s), TypeSub(t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, r), TypeRel(s'', t'', NONEMPTY), r != EMPTY.

    TypeRel(s, t, NONEMPTY) :- TypeSub(s), TypeSub(t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, SUB), TypeRel(s'', t'', SUP), fs.type != ft.type, s'' != t''.
                               
    //// (3) Sub-typing. 
                
    // If two types are subtype-related, then they are also supertype-related.
    TypeRel(t, s, SUP) :- TypeRel(s, t, SUB).            
                               
    // Any non-ERROR type is subtype related to itself.
    TypeRel(t, t, SUB) :- TypeSub(t), t != ERROR.
    
    // Every proper type is a sub-type of any.
    TypeRel(t, bany, SUB) :- TypeSub(t), t != ERROR, t != NIL, bany = BaseType(ANY).
    
    // For convenience, NIL is a subtype of itself
    TypeRel(NIL, NIL, SUB).
    
    // NULL is a subtype of all Nullable types.
    TypeRel(null, bany, SUB) :- null = BaseType(NULL), bany = BaseType(ANY).
    TypeRel(null, t, SUB)    :- TypeSub(t), t = BaseType(kt), kt : NullBase, null = BaseType(NULL).
    
    // Sequences are subtype related if their inner types are subtype related.
    TypeRel(s, t, SUB)    :- TypeSub(s), TypeSub(t), s = SeqType(s'), t = SeqType(t'), TypeRel(s', t', SUB). 
    
    // Maps are subtype related if their inner types are subtype related.
    TypeRel(s, t, SUB) :- TypeSub(s), TypeSub(t), s = MapType(sd, sc), t = MapType(td, tc), TypeRel(sd, td, SUB), TypeRel(sc, tc, SUB). 
    
    // Tuples are subtype related if their inner types are subtype related.
    TypeRel(s, t, SUB) :- TypeSub(s), TypeSub(t), s = TupType(s', s''), t = TupType(t', t''), TypeRel(s', t', SUB), TypeRel(s'', t'', SUB).
    
    TypeRel(s, t, SUB) :- TypeSub(s), TypeSub(t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                          TypeRel(fs.type, ft.type, SUB), TypeRel(s'', t'', SUB).    
 }