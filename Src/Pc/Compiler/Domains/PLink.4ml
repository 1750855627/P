[
   modules.C = '"C at C.4ml"'
]

domain PLink
{
	IdList  ::= new (val: Integer + String, tl: any IdList + { NIL }).
	Id ::= { NIL } + Integer + String + IdList.
	NonNullEventName  ::= String + { HALT }.
	EventName         ::= String + { NULL, HALT }.
	EventNameList ::= new (hd: EventName, tl: any EventNameList + { NIL }).

	NameType        ::= new (name: String).
    BaseType        ::= new ({ NULL, BOOL, INT, EVENT, MACHINE, ANY }).
    TupType         ::= new (hd: any TypeExpr, tl: any TupType + { NIL }).
    NmdTupType      ::= new (hd: any NmdTupTypeField, tl: any NmdTupType + { NIL }).
    SeqType         ::= new (x: any TypeExpr).
    MapType         ::= new (k: any TypeExpr, v: any TypeExpr).
    NmdTupTypeField ::= new (name: any String, type: any TypeExpr). 
	InterfaceType	::= new (ev: NonNullEventName, tail: any InterfaceType + {NIL}).
    TypeExpr        ::= NameType + BaseType + TupType + NmdTupType + SeqType + MapType + InterfaceType.

	StringList		::= new (hd: String, tl: any StringList + { NIL }).
	IntegerList		::= new (hd: Integer, tl: any IntegerList + { NIL }).
	EnumTypeDef	    ::= fun (name: String -> elems: any StringList, values: any IntegerList + { NIL }).
	TypeDef         ::= fun (name: String -> type: any TypeExpr).
	ModelType       ::= new (name: String).

    AssumeMaxInstances	::= new (bound: Natural).
    AssertMaxInstances	::= new (bound: Natural).
    QueueConstraint		::= AssumeMaxInstances + AssertMaxInstances + { NIL }.
    EventDecl			::= fun (name: String -> card: any QueueConstraint, type: any TypeExpr + { NIL }).
	AnonFunDecl		    ::= new (ownerFun: String, anonFunIndex: Natural).
	FunDecl				::= fun (name: String -> params: any NmdTupType + { NIL }, return: any TypeExpr + { NIL }, id: any Id).
	FunProtoDecl		::= fun (name: String -> params: any NmdTupType + { NIL }, return: any TypeExpr + { NIL }).
	Impure				::= new (decl: FunDecl + FunProtoDecl).
	EventSet			::= fun (name: String -> list: any EventNameList + { NIL }).
	InterfaceTypeDecl	::= fun (name: String -> list: EventNameList, argType: any TypeExpr).
    MachineDecl			::= fun (name: String -> constType: any TypeExpr, id: any Id).
	MachineProtoDecl	::= new (name: String, constType: any TypeExpr).
	

	AvailableParameterDemand   ::= new (fname: String, pname: String).
	UnavailableParameterSupply ::= new (fname: String, pname: String).

	/*****************************************************************/
	/*		Module system related declarations and constructs		 */
	/*****************************************************************/

	//// Machine Signature
	MachineExports		::= fun (mach: String -> exports: String).
	MachineReceives		::= new (mach: String, ev: NonNullEventName).
	MachineSends		::=	new (mach: String, ev: NonNullEventName).
	MachineCreatesInt	::= new (mach: String, iname: String).
	MachineCreatesM		::= new (mach: String, mmname: String).

	//// Module Declarations
	ModuleDecl ::= new (name: String).
	ModuleContains ::= new (lmod: ModuleDecl, mach: MachineDecl).
	ModulePrivateEvents ::= new (mod: ModuleDecl, ev: NonNullEventName + { NIL }).
	ModuleName ::= new (name: String).
	

	/// Module Constructions
	ModuleDef ::= new (name: String, mod: any ModuleExpr).
	HideExpr ::= new (evtNames: any EventNameList, mod: any ModuleExpr, id: any Id). 
	RenameExpr ::= new (mNames: String, mNames': String, mod: any ModuleExpr, id: any Id).
	ExportExpr ::= new (mName: String, iName: String, mod: any ModuleExpr, id: any Id).
	AssumeExpr ::= new (monNames: any MonitorNameList, mod: any ModuleExpr, id: any Id).
	AssertExpr ::= new (monNames: any MonitorNameList, mod: any ModuleExpr, id: any Id).
	SafeExpr ::= new (mod: any ModuleExpr, id: any Id).
	ComposeExpr ::= new (left: any ModuleExpr, right: any ModuleExpr, id: any Id).
	ModuleExpr ::= ModuleName + HideExpr + RenameExpr + ExportExpr + AssumeExpr + AssertExpr + SafeExpr + ComposeExpr + ModuleDecl.

	//// Test Declarations and Implementation
	TestDecl ::= new (name: String, mod: any ModuleExpr, id: any Id).
	RefinementDecl ::= new (name: String, lhs: any ModuleExpr, rhs: any ModuleExpr, id: any Id).
	ImplementationDecl ::= new (mod: any ModuleExpr, id: any Id).

	//// Module Signature 
	ModulePrivate ::= (mod: ModuleExpr, ev: NonNullEventName).
	ModuleSends ::= (mod: ModuleExpr, ev: NonNullEventName).
	ModuleReceives ::= (mod: ModuleExpr, ev: NonNullEventName).
	ModuleExports ::= (mod: ModuleExpr, i: String).  
	ModuleCreates ::= (mod: ModuleExpr, i: String).

	//// Module Code Gen and Compatibity Helpers
	ModuleLinkMap ::= (mod: ModuleExpr, newMachineName: String, interfaceOrMachine: String, newImpMachine: String + {NIL}).
	ModuleRenameMap ::= (mod: ModuleExpr, newName: String, impMachine: MachineDecl).  // for both machines and monitors
	ModuleSafeMap ::= (mod: ModuleExpr, newName: String, isSafe: Boolean).
	ModuleMonitorMap ::= (mod: ModuleExpr, newMonitorName: String, impMachine: String).

	// MonitorNamesList
	MonitorNameList ::= new (str: String, tl: any MonitorNameList + { NIL }).
	MemberOfMonitorNameList ::= sub (MonitorNameList, String).
	MemberOfEventNameList ::= sub (EventNameList, EventName).
}

domain PLinkError
{
	IdList  ::= new (val: Integer + String, tl: any IdList + { NIL }).
	Id ::= { NIL } + Integer + String + IdList.
	//// General linker errors
	OneNameError ::= new (name: String, msg: String).
	TwoNameError ::= new (name1: String, name2: String, msg: String).

	//// Module system related linker errors
	ModuleDefError ::= new (name: String, msg: String).
	NoMainMachineInModExpr ::= new (modExprId: any Id, msg: String).
}

transform PLink2C(in:: PLink) returns (err:: PLinkError, out:: C)
{
	//// General Linker Errors
	err.OneNameError(name, "multiple machines with same name") :- m is MachineDecl, m' is MachineDecl, m != m', m.name = m'.name, name = m.name.

	err.OneNameError(name, "multiple functions with same name") :- f is FunDecl, f' is FunDecl, f != f', f.name = f'.name, name = f.name.

	err.OneNameError(iname, "created interface not exported") :- MachineCreatesInt(_, iname), no MachineExports(_, iname).
	
	err.OneNameError(iname, "multiple machines export the same interface") :- m is MachineDecl, m' is MachineDecl, m.name != m'.name, MachineExports(m.name, iname), MachineExports(m'.name, iname).
	
	err.OneNameError(mp.name, "machine prototype not implemented") :- mp is MachineProtoDecl, no MachineDecl(mp.name, _, _).
	
	err.OneNameError(mp.name, "constructor type does not match") :- mp is MachineProtoDecl, m is MachineDecl, mp.name = m.name, mp.constType != m.constType.
	
	err.OneNameError(fp.name, "parameter type does not match") :- fp is FunProtoDecl, f is FunDecl, fp.name = f.name, fp.params != f.params.
	err.OneNameError(fp.name, "return type does not match") :- fp is FunProtoDecl, f is FunDecl, fp.name = f.name, fp.return != f.return.

	err.OneNameError(fp.name, "function prototype not implemented") :- fp is FunProtoDecl, no FunDecl(fp.name, _, _, _).

	err.OneNameError(iname, "machine cannot have the same name as interface") :- i is InterfaceTypeDecl(iname, _, _), MachineDecl(iname, _, _).
	err.OneNameError(iname, "machine prototype cannot have the same name as interface") :- i is InterfaceTypeDecl(iname, _, _), MachineProtoDecl(iname, _).

	err.TwoNameError(fname, pname, "function parameter must be available at return") :- AvailableParameterDemand(fname, pname), UnavailableParameterSupply(fname, pname).

	//// Module System related Linker Errors

	//// Check if the named module definition is legal ////
	ModuleDefError(name, "undefined module") :- AllModuleExprs(modEx), modEx = ModuleName(name), no ModuleDecl(name), no ModuleDef(name, _).

	ModuleDefError(modName, "multiple named module definitions with the same name") :- ModuleDef(modName, expr1), ModuleDef(modName, expr2), expr1 != expr2.

	ModuleDefDepends ::= sub (modDef: ModuleDef, mName: ModuleName).
	ModuleNameDepends ::= (name1: String, name2: String).
	ModuleNameDepends(nmodule.name, modName.name) :- ModuleDefDepends(nmodule, modName).
	ModuleNameDepends(name1, name3) :- ModuleNameDepends(name1, name2), ModuleNameDepends(name2, name3).

	ModuleDefError(name, "named module depends on itself") :- ModuleNameDepends(name, name).

	//// Expand ModuleExpr
	AllModuleExprs ::= sub (ModuleExpr).
	ModuleExprExpansion ::= (modExpr: ModuleExpr, eModExpr: ModuleExpr).
	
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = ModuleName(name), emodExpr = ModuleDecl(name), no ModuleDef(name, _).
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = ModuleName(name), no ModuleDefError(name, _), no ModuleDecl(name), ModuleDef(name, modExpr'), ModuleExprExpansion(modExpr', emodExpr).
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = ModuleDecl(name), emodExpr = ModuleDecl(name).
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = HideExpr(s, modExpr', id), emodExpr = HideExpr(s, emodExpr', id),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = RenameExpr(s1, s2, modExpr', id), emodExpr = RenameExpr(s1, s2, emodExpr', id),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = ExportExpr(s1, s2, modExpr', id), emodExpr = ExportExpr(s1, s2, emodExpr', id),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = AssumeExpr(s, modExpr', id), emodExpr = AssumeExpr(s, emodExpr', id),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = AssertExpr(s, modExpr', id), emodExpr = AssertExpr(s, emodExpr', id),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = SafeExpr(modExpr', id), emodExpr = SafeExpr(emodExpr', id),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = ComposeExpr(modExpr', modExpr'', id), emodExpr = ComposeExpr(emodExpr', emodExpr'', id), ModuleExprExpansion(modExpr', emodExpr'), ModuleExprExpansion(modExpr'', emodExpr'').

	//// All expanded Module Exprs
	AllExpandedModuleExprs ::= (modExpr: ModuleExpr).
	AllExpandedModuleExprs(emodExpr) :- AllModuleExprs(modExpr), ModuleExprExpansion(modExpr, emodExpr).

	//// All leaf modules in module expr
	AllModuleDecls ::= (modExpr: ModuleExpr, mod: ModuleDecl).
	AllModuleDecls(modExpr, mod) :- AllExpandedModuleExprs(modExpr), toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #ModuleDecl, AllModuleDecls(modExpr.mod, mod).
	AllModuleDecls(modExpr, mod) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, mod = modExpr.
	AllModuleDecls(modExpr, mod) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, AllModuleDecls(modExpr.left, mod);
									AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, AllModuleDecls(modExpr.right, mod).
	

	/**************************************************************************/
	/*	Check that there is main machine in each moduleExpr in the test decl  */
	/**************************************************************************/
	NoMainMachineInModExpr(id, "no Main machine in the module expression in test decl") :-
			TestDecl(_, modExpr, id), ModuleExprExpansion(modExpr, emodExpr), no ModuleRenameMap(emodExpr, "Main", _);
			RefinementDecl(_, modExpr, _, id), ModuleExprExpansion(modExpr, emodExpr), no ModuleRenameMap(emodExpr, "Main", _);
			RefinementDecl(_, _, modExpr, id), ModuleExprExpansion(modExpr, emodExpr), no ModuleRenameMap(emodExpr, "Main", _).





	/************************************************************************************/
	/*	Generate sends, receives, exports, private and creates for Module Expressions   */
	/************************************************************************************/
	/*
	//// private events 
	PrivateForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, ModulePrivateEvent(modExpr, ev);
										 AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, ModulePrivateEventAll(modExpr), MachineReceivesDecl(mach, ev), mach.mod = modExpr.
	PrivateForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), toSymbol(modExpr) != #HideExpr, toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #ModuleDecl, PrivateForModuleExpr(modExpr.mod, ev).
	PrivateForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : HideExpr, PrivateForModuleExpr(modExpr.mod, ev);
										 AllExpandedModuleExprs(modExpr), modExpr : HideExpr, MemberOfStringsList(modExpr.evtNames, ev).
	PrivateForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, PrivateForModuleExpr(modExpr.left, ev);
										 AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, PrivateForModuleExpr(modExpr.right, ev).
									 

	//// sends list 
	SendsForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, MachineSendsDecl(mach, ev), mach.mod = modExpr, no ModulePrivateEvent(modExpr, ev). 
	SendsForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), toSymbol(modExpr) != #HideExpr, toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #ModuleDecl, SendsForModuleExpr(modExpr.mod, ev).
	SendsForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, SendsForModuleExpr(modExpr.left, ev);
									   AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, SendsForModuleExpr(modExpr.right, ev).
	SendsForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : HideExpr, MachineSendsDecl(_, ev), SendsForModuleExpr(modExpr.mod, ev), no MemberOfStringsList(modExpr.evtNames, ev).
	


	//// exports list
	AllExportedInterfaces ::= (ix: String).
	AllExportedInterfaces(ix) :- ExportExpr(_, ix, _); MachineExportsDecl(_, ix).
	ExportsForModuleExpr(modExpr, ix) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, MachineExportsDecl(mach, ix), mach.mod = modExpr.
	ExportsForModuleExpr(modExpr, ix) :- AllExpandedModuleExprs(modExpr), ExportsForModuleExpr(modExpr.mod, ix),
										 toSymbol(modExpr) != #HideExpr, toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #ModuleDecl, toSymbol(modExpr) != #ExportExpr.
	ExportsForModuleExpr(modExpr, ix) :- AllExpandedModuleExprs(modExpr), modExpr : ExportExpr, ExportsForModuleExpr(modExpr.mod, ix);
										 AllExpandedModuleExprs(modExpr), modExpr : ExportExpr, ix = modExpr.iName.
	ExportsForModuleExpr(modExpr, ix) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ExportsForModuleExpr(modExpr.left, ix);
									     AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ExportsForModuleExpr(modExpr.right, ix).									 
	ExportsForModuleExpr(modExpr, ix) :- AllExpandedModuleExprs(modExpr), modExpr : HideExpr, AllExportedInterfaces(ix), ExportsForModuleExpr(modExpr.mod, ix), InterfaceTypeDecl(ix, es, _), count({ev | EventSetDecl(es, ev), MemberOfStringsList(modExpr.evtNames, ev)}) = 0.

	//// creates list
	AllCreatedInterfaces ::= (ic: String).
	AllCreatedInterfaces(ic) :- MachineCreatesDecl(_, ic).
	CreatesForModuleExpr(modExpr, ic) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, MachineCreatesDecl(mach, ic), mach.mod = modExpr.
	CreatesForModuleExpr(modExpr, ic) :- AllExpandedModuleExprs(modExpr), CreatesForModuleExpr(modExpr.mod, ic),
										 toSymbol(modExpr) != #HideExpr, toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #ModuleDecl.
	CreatesForModuleExpr(modExpr, ic) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, CreatesForModuleExpr(modExpr.left, ic);
									     AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, CreatesForModuleExpr(modExpr.right, ic).									 
	CreatesForModuleExpr(modExpr, ic) :- AllExpandedModuleExprs(modExpr), modExpr : HideExpr, AllCreatedInterfaces(ic), CreatesForModuleExpr(modExpr.mod, ic), InterfaceTypeDecl(ic, es, _), count({ev | EventSetDecl(es, ev), MemberOfStringsList(modExpr.evtNames, ev)}) = 0.

	//// receives list
	ReceivesForModuleExpr(modExpr, er) :- AllExpandedModuleExprs(modExpr), ExportsForModuleExpr(modExpr, ix), InterfaceTypeDecl(ix, es, _), EventSetDecl(es, er).
	

	*/
    /*************************************************************/
    /**********         Create Header File             ***********/
    /*************************************************************/
    //// Elements will be output to header file in order of position.
    HOut ::= (pos: Natural, cmp: out.Cmp).
    HOutOrder ::= (ord: Natural, cmp: out.Cmp).
	HOutOrder(o, cmp) :- ho is HOut(_, cmp), o = toOrdinal(ho, 0, { ho' | ho' is HOut }). 

    //// Concat elements in order.
	HConcatOut ::= (pos: Integer, cmp: out.Cmp).	
	HConcatOut(-1, NIL).
	HConcatOut(m', cmp) :- HConcatOut(m, before), HOutOrder(m', nxt), m' = m + 1, cmp = Section(before, nxt). 		
		
	out.File(headerFileName, body) :- HConcatOut(count({ho | ho is HOut}) - 1, cmp), 
								      headerFileName = "linker.h",
									  ifdefBegin = PpITE(IFDEF, Ident("__cplusplus"), PpEscape(Ident("extern \"C\"{")), NIL),
									  ifdefEnd = PpITE(IFDEF, Ident("__cplusplus"), PpEscape(Ident("}")), NIL),
									  body = PpITE(
									   IFNDEF,
									   Ident("P_LINKER_H"),
									   Section(
										   Section(
											  PpDefine(Ident("P_LINKER_H"), NIL),
											  Section(
											     PpInclude("PrtUser.h", FALSE),
											     PpInclude("PrtExecution.h", FALSE)											  
											  )),
										   Section(ifdefBegin, Section(cmp, ifdefEnd))),
									   NIL).

    /*************************************************************/
    /**********         Create Code File               ***********/
    /*************************************************************/
    //// Elements will be output to c file in order of position.
    COut ::= (pos: Natural, cmp: out.Cmp).
	COutOrder ::= (ord: Natural, cmp: out.Cmp).

    //// Concat elements in order.
	COutOrder(o, cmp) :- co is COut(_, cmp), o = toOrdinal(co, 0, { co' | co' is COut }). 
	CConcatOut ::= (pos: Integer, cmp: out.Cmp).	
	CConcatOut(-1, NIL).
	CConcatOut(m', cmp) :- CConcatOut(m, before), COutOrder(m', nxt), m' = m + 1, cmp = Section(before, nxt). 		
		
	out.File(codeFileName, body) :- CConcatOut(count({co | co is COut}) - 1, cmp),
	                               headerFileName = "linker.h",
								   codeFileName = "linker.c",
								   body = Section(PpInclude(headerFileName, FALSE), cmp).

	/*************************************************************/
    /**********   Generate contents of header file     ***********/
    /*************************************************************/
	
	EventDeclExt ::= EventDecl + { NULL, HALT }.
	DeclId ::= (decl: MachineDecl + EventDecl + FunDecl + AnonFunDecl + { NULL, HALT }, id: Natural, cname: String).
	
	//// Foreign types
	HOut(0, out.EnmDef(NIL, "P_FORGN_TYPES", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   ModelType(name), id = toOrdinal(name, 0, { n | ModelType(n) }), cn = strJoin("P_FORGN_TYPE_", name), enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_FORGN_TYPES_COUNT"), size = count({n | ModelType(n)}) }).  
	
	//// Field names for named tuple types that have a type synonym
	IndexOf ::= (t: NmdTupType, name: String, offset: Natural, tail: NmdTupType + {NIL}).
	IndexOf(t, name, 0, tail)  :- TypeDef(_, t), t = NmdTupType(NmdTupTypeField(name, _), tail).
	IndexOf(t, name, i', tail) :- IndexOf(t, _, i, tail'), tail' = NmdTupType(NmdTupTypeField(name, _), tail), i' = i + 1.

	HOut(0, out.EnmDef(NIL, enumName, list)) :- 
	   d is TypeDef(name, type), type: NmdTupType, enumName = strJoin("P_FIELD_INDEX_", name),
	   list = toList(#Elements, NIL, { enumMember | 
									   IndexOf(type, f, offset, _), cn = strJoin(strJoin(enumName, "_"), f), enumMember = Element(IntLit(offset, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), strJoin(strJoin("_", enumName), "_COUNT")), size = lstLength(#NmdTupType, type) }).  
	
	//// Enum declarations for all enum types
	EnumTypeElem ::= (EnumTypeDef, StringList, IntegerList + { NIL }).
	EnumTypeElem(d, list1, list2) :- d is EnumTypeDef(_, list1, list2).
	EnumTypeElem(d, list1, NIL) :- EnumTypeElem(d, StringList(_, list1), NIL), list1: StringList.
	EnumTypeElem(d, list1, list2) :- EnumTypeElem(d, StringList(_, list1), IntegerList(_, list2)), list1: StringList.

	EnumTypeElemIndex ::= (EnumTypeDef, StringList, IntegerList + { NIL }, String, Integer).
	EnumTypeElemIndex(d, list, NIL, str, i) :- EnumTypeElem(d, list, NIL), list = StringList(str, NIL), i = lstLength(#StringList, d.elems) - 1.
	EnumTypeElemIndex(d, list, NIL, str, i) :- EnumTypeElem(d, list, NIL), list = StringList(str, list'), 
											   EnumTypeElemIndex(d, list', NIL, _, j), i = j - 1.
  	EnumTypeElemIndex(d, list1, list2, str, i) :- EnumTypeElem(d, list1, list2), 
												  list1 = StringList(str, _), list2 = IntegerList(i, _).

	HOut(0, out.EnmDef(NIL, enumName, list)) :-
		d is EnumTypeDef(enumName, elems, _), size = lstLength(#StringList, elems),
		list = toList(#Elements, NIL, { enumMember | 
										EnumTypeElemIndex(d, _, _, name, offset), cn = strJoin(strJoin(enumName, "_"), name), enumMember = Element(IntLit(offset, DEC, NIL), cn);
										enumMember = Element(IntLit(size, DEC, NIL), strJoin(strJoin("_", enumName), "_COUNT")) }).  
	
	//// EventDecls - Id 0, 1 are reserved for null, halt event, which can appear in transition tables.
	DeclId(NULL, 0, "_P_EVENT_NULL").
	DeclId(HALT, 1, "_P_EVENT_HALT").
	DeclId(d, id, cn) :- d is EventDecl, id = 2 + toOrdinal(d, 0, { d' | d' is EventDecl }), cn = strJoin("P_EVENT_", d.name).
	
	HOut(0, out.EnmDef(NIL, "P_EVENTS", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : EventDeclExt, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_EVENTS_COUNT"), size = 2 + count({d | d is EventDecl}) }).  
			
	//// EventSetDecls
	HOut(0, out.EnmDef(NIL, "P_EVENTSET", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   EventSet(evsetName, eventNameList), id = toOrdinal(eventNameList, 0, { x | EventSet(_, x) }), enumMember = Element(IntLit(id, DEC, NIL), evsetName); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_EVENTSETS_COUNT"), size = count({ x | x is EventSet }) }).  
	
	//// (Anon)FunDecls
	AnonOrNamedFun ::= FunDecl + AnonFunDecl.
	DeclId(d, id, cn) :- 
		d is FunDecl, id = 1 + toOrdinal(d, 0, { d' | d' is AnonOrNamedFun }), 
							 cn = strJoin("P_FUN_", d.name);
		d is AnonFunDecl, id = 1 + toOrdinal(d, 0, { d' | d' is AnonOrNamedFun }),
							 cn = strJoin("P_FUN_", strJoin(d.ownerFun, strJoin("_ANON", toString(d.anonFunIndex)))).

	HOut(0, out.EnmDef(NIL, "P_FUNS", list)) :-
		list = toList(#Elements, NIL, { enumMember |
									   enumMember = Element(IntLit(0, DEC, NIL), "_P_FUN_PUSH_OR_IGN"); 
									   DeclId(d, id, cn), d is AnonOrNamedFun, x = 2*id, enumMember = Element(IntLit(x, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_FUNS_COUNT"), size = 1 + count({d | d is AnonOrNamedFun}) }).

	HOut(0, def) :- d is AnonOrNamedFun, DeclId(d, _, funName), funStructName = strJoin(funName, "_STRUCT"),
	                        def = out.VarDef(
							      EXTERN, 
								  NmdType(NIL, "PRT_FUNDECL"), 
								  funStructName, 
								  NIL).

	//// Machine decls - Start at Id 0.
	DeclId(d, id, cn) :- d is MachineDecl, id = toOrdinal(d, 0, { d' | d' is MachineDecl }), cn = strJoin("P_MACHINE_", d.name).
	
	HOut(0, out.EnmDef(NIL, "P_MACHINES", list)) :- 
	   list = toList(#Elements, NIL, { enumMember | 
									   DeclId(d, id, cn), d : MachineDecl, enumMember = Element(IntLit(id, DEC, NIL), cn); 
									   enumMember = Element(IntLit(size, DEC, NIL), "_P_MACHINES_COUNT"), size = count({d | d is MachineDecl}) }).  

	HOut(0, def) :- d is MachineDecl, machineName = strJoin("P_MACHINE_", d.name), machineStructName = strJoin(machineName, "_STRUCT"),
	                        def = out.VarDef(
							      EXTERN, 
								  NmdType(NIL, "PRT_MACHINEDECL"), 
								  machineStructName, 
								  NIL).

	//// Extern declarations for defined types
	HOut(0, def) :- TypeDef(name, _), 
					typeName = strJoin("P_GEND_TYPE_", name),
					def = out.VarDef(EXTERN, PtrType(NmdType(NIL, "PRT_TYPE")), typeName, NIL).

	HOut(0, def) :- ModelType(name), 
					typeName = strJoin("P_GEND_TYPE_", name),
					def = out.VarDef(EXTERN, PtrType(NmdType(NIL, "PRT_TYPE")), typeName, NIL).
	
	//// Extern declarations for foreign type functions
	HOut(0, def) :- ModelType(name),
	                params = NIL,
				    funType = FunType(NmdType(NIL, "PRT_UINT64"), argTypes),
					argTypes = PrmTypes(BaseType(VOID), NIL),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_MKDEF_", strJoin(name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(0, def) :- ModelType(name),
	                params = Params(Param(NIL, "frgnVal"), NIL),
				    funType = FunType(NmdType(NIL, "PRT_UINT64"), argTypes),
					argTypes = PrmTypes(NmdType(NIL, "PRT_UINT64"), NIL),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_CLONE_", strJoin(name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(0, def) :- ModelType(name),
	                params = Params(Param(NIL, "frgnVal"), NIL),
				    funType = FunType(BaseType(VOID), argTypes),
					argTypes = PrmTypes(NmdType(NIL, "PRT_UINT64"), NIL),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_FREE_", strJoin(name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(0, def) :- ModelType(name),
	                params = Params(Param(NIL, "frgnVal"), NIL),
				    funType = FunType(NmdType(NIL, "PRT_UINT32"), argTypes),
					argTypes = PrmTypes(NmdType(NIL, "PRT_UINT64"), NIL),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_GETHASHCODE_", strJoin(name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(0, def) :- ModelType(name),
	                params = Params(Param(NIL, "frgnVal"), NIL),
				    funType = FunType(NmdType(NIL, "PRT_STRING"), argTypes),
					argTypes = PrmTypes(NmdType(NIL, "PRT_UINT64"), NIL),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_TOSTRING_", strJoin(name, "_IMPL")),
					  params,
					  UNKNOWN).

	HOut(0, def) :- ModelType(name),
	                params = Params(Param(NIL, "frgnVal1"),
					         Params(Param(NIL, "frgnVal2"), 
							 NIL)),
				    funType = FunType(NmdType(NIL, "PRT_BOOLEAN"), argTypes),
					argTypes = PrmTypes(NmdType(NIL, "PRT_UINT64"), 
							   PrmTypes(NmdType(NIL, "PRT_UINT64"), 
							   NIL)),					  
	                def = FunDef(
					  NIL,
					  funType,
					  strJoin("PRT_FORGN_ISEQUAL_", strJoin(name, "_IMPL")),
					  params,
					  UNKNOWN).

	//// Extern declaration for Program Decl
	HOut(0, def) :- def = out.VarDef(
							      EXTERN, 
								  NmdType(NIL, "PRT_PROGRAMDECL"), 
								  "P_GEND_PROGRAM", 
								  NIL).

	/*************************************************************/
    /**********   Generate contents of code file     ***********/
    /*************************************************************/

	//// Labels a type expression with a number greater than the labels of all its sub-expressions.
	//// TypeId linearizes the dependency order to get a schedule for emitting type expressions.
	TypeId      ::= (id: Natural, type: TypeExpr).
	TypeDepNum  ::= (id: Natural, type: TypeExpr).

	TranslatedTypeExpr ::= (TypeExpr).
	TranslatedTypeExpr(t) :- t = in.BaseType(NULL); t = in.BaseType(BOOL); t = in.BaseType(INT); t = in.BaseType(EVENT); t = in.BaseType(MACHINE); t = in.BaseType(ANY).
	TranslatedTypeExpr(t) :- ModelType(name), t = NameType(name).
	TranslatedTypeExpr(t) :- EventDecl(_, _, t), t : TypeExpr.
	TranslatedTypeExpr(t) :- InterfaceTypeDecl(_, _, t).
	TranslatedTypeExpr(t) :- TypeDef(_, t).
	TranslatedTypeExpr(t) :- TranslatedTypeExpr(t'), t' = SeqType(t).
	TranslatedTypeExpr(t) :- TranslatedTypeExpr(t'), t' = MapType(t, _).
	TranslatedTypeExpr(t) :- TranslatedTypeExpr(t'), t' = MapType(_, t).
	TranslatedTypeExpr(t) :- TranslatedTypeExpr(t'), t' = TupType(t, _).  
	TranslatedTypeExpr(t) :- TranslatedTypeExpr(t'), t' = TupType(_, t), t: TypeExpr.  
	TranslatedTypeExpr(t) :- TranslatedTypeExpr(t'), t' = NmdTupType(NmdTupTypeField(_, t), _).
	TranslatedTypeExpr(t) :- TranslatedTypeExpr(t'), t' = NmdTupType(_, t), t: TypeExpr.  

	TypeDepNum(0, t) :- TranslatedTypeExpr(t), t : in.BaseType.
	TypeDepNum(0, t) :- TranslatedTypeExpr(t), t : in.NameType. 
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = in.SeqType(t'), TypeDepNum(j, t'), i = j + 1.  
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = in.MapType(t', t''), TypeDepNum(j, t'), TypeDepNum(k, t''),  i = j + k + 1.  
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = in.TupType(t', NIL), TypeDepNum(j, t'), i = j + 1.  
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = in.TupType(t', t''), TypeDepNum(j, t'), TypeDepNum(k, t''),  i = j + k + 1.  
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = in.NmdTupType(NmdTupTypeField(_, t'), NIL), TypeDepNum(j, t'), i = j + 1.  
	TypeDepNum(i, t) :- TranslatedTypeExpr(t), t = in.NmdTupType(NmdTupTypeField(_, t'), t''), TypeDepNum(j, t'), TypeDepNum(k, t''), i = j + k + 1.  
	TypeId(id, t) :- td is TypeDepNum(_, t), id = toOrdinal(td, 0, { td' | td' is TypeDepNum }).

	//// Build type initializers in linearization order.
	//// defs is the definitions that precede the encoding of this type constant.
	TypeConstant ::= (type: TypeExpr + { NIL }, typeExprId: Integer, defs: out.Section + { NIL }).
	TypeConstant(NIL, -1, NIL).

	//// Base types
	BaseType2Kind ::= ({ NULL, BOOL, INT, EVENT, MACHINE, ANY }, String).
	BaseType2Kind(NULL, "PRT_KIND_NULL").
	BaseType2Kind(BOOL, "PRT_KIND_BOOL").
	BaseType2Kind(INT, "PRT_KIND_INT").
	BaseType2Kind(EVENT, "PRT_KIND_EVENT").
	BaseType2Kind(MACHINE, "PRT_KIND_MACHINE").
	BaseType2Kind(ANY, "PRT_KIND_ANY").
	
	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), t = in.BaseType(base), BaseType2Kind(base, kind),
								defs = out.Section(before, def),
								def = out.VarDef(NIL, NmdType(NIL, "PRT_TYPE"), typeName, typeStruct),
								typeName = strJoin("P_GEND_TYPE_", toString(m)),
                                typeStruct = out.Init(Args(Ident(kind), Args(Init(Args(Ident("NULL"), NIL)), NIL))).						              

	//// Enum types
	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), t = NameType(name), EnumTypeDef(name, _, _),
								defs = out.Section(before, def),
								def = out.VarDef(NIL, NmdType(NIL, "PRT_TYPE"), typeName, typeStruct),
								typeName = strJoin("P_GEND_TYPE_", toString(m)),
                                typeStruct = out.Init(Args(Ident("PRT_KIND_INT"), Args(Init(Args(Ident("NULL"), NIL)), NIL))).						              
	
	//// Foreign types
	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), t = NameType(name), ModelType(name),
								defs = out.Section(before, def),
								def = out.VarDef(NIL, NmdType(NIL, "PRT_TYPE"), typeName, typeStruct),
								typeName = strJoin("P_GEND_TYPE_", toString(m)),
								indexName = strJoin("P_FORGN_TYPE_", name),
                                typeStruct = out.Init(Args(Ident("PRT_KIND_FORGN"), 
								                      Args(Init(Args(Cast(PtrType(NmdType(NIL, "PRT_MAPTYPE")), Ident(indexName)), NIL)), NIL))).						              
	
	//// Complex type Seq 
	//// (cast to PRT_MAPTYPE * is used to avoid compiler warnings when initializing union)
	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), t = SeqType(tinner), TypeConstant(tinner, tinnerid, _),
								              defs = out.Section(Section(before, defSeq), def),
                              defSeq = out.VarDef(
                                     NIL, 
                                     NmdType(NIL, "PRT_SEQTYPE"), 
                                     typeNameSeq, 
                                     Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(tinnerid)))), NIL))),										 
                              def = out.VarDef(
                                     NIL, 
                                     NmdType(NIL, "PRT_TYPE"), 
                                     strJoin("P_GEND_TYPE_", toString(m)), 
                                     typeStruct),
								              typeStruct = out.Init(
										              Args(Ident("PRT_KIND_SEQ"), 
											            Args(Init(Args(Cast(PtrType(NmdType(NIL, "PRT_MAPTYPE")), UnApp(ADDR, Ident(typeNameSeq))), NIL)), 
											            NIL))),
									            typeNameSeq = strJoin("P_GEND_TYPE_SEQ_", toString(m)). 

	//// Complex type Map 
	TypeConstant(t, m, defs) :- 
	                       TypeId(m, t), TypeConstant(_, m - 1, before), t = MapType(tdom, tcod), 
	                       TypeConstant(tdom, domid, _), TypeConstant(tcod, codid, _),
								         defs = out.Section(Section(before, defMap), def),
										     defMap = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_MAPTYPE"), 
														  typeNameMap, 
														  Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(domid)))), 
														       Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(codid)))), 
														       NIL)))),
										      def = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_TYPE"), 
														  strJoin("P_GEND_TYPE_", toString(m)), 
														  typeStruct),
							            typeStruct = out.Init(
										            Args(Ident("PRT_KIND_MAP"), 
											          Args(Init(Args(UnApp(ADDR, Ident(typeNameMap)), NIL)), 
											          NIL))),														  
										      typeNameMap = strJoin("P_GEND_TYPE_MAP_", toString(m)).
	//// Complex type Tuple 
	Tup2ArrayInit ::= (type: TupType, arr: out.Expr). 
	Tup2ArrayInit(t, init) :- TranslatedTypeExpr(t), t = TupType(t', NIL), TypeConstant(t', id', _), init = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), NIL)). 
	Tup2ArrayInit(t, init) :- TranslatedTypeExpr(t), t = TupType(t', t''), TypeConstant(t', id', _), Tup2ArrayInit(t'', Init(ts'')), 
	                          init = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), ts'')). 

	TypeConstant(t, m, defs) :- 
	                       TypeId(m, t), TypeConstant(_, m - 1, before), Tup2ArrayInit(t, arrInit), t : TupType, 
								         defs = out.Section(Section(before, Section(defTupArr, defTup)), def),
										     defTupArr = out.VarDef(
										           NIL, 
															 ArrType(PtrType(NmdType(NIL, "PRT_TYPE")), NIL), 
															 typeNameTupArr, 
															 arrInit),
										     defTup = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_TUPTYPE"), 
														  typeNameTup, 
														  Init(
														    Args(IntLit(lstLength(#TupType, t), DEC, NIL), 
															  Args(Ident(typeNameTupArr), 
															  NIL)))),
										     def = out.VarDef(
										         NIL, 
													   NmdType(NIL, "PRT_TYPE"), 
													   strJoin("P_GEND_TYPE_", toString(m)), 
													   typeStruct),
										    typeStruct = out.Init(
													  Args(Ident("PRT_KIND_TUPLE"), 
													  Args(Init(Args(Cast(PtrType(NmdType(NIL, "PRT_MAPTYPE")), UnApp(ADDR, Ident(typeNameTup))), NIL)),
													  NIL))),
										     typeNameTupArr = strJoin("P_GEND_TYPE_TUP_ARR_", toString(m)),
										     typeNameTup = strJoin("P_GEND_TYPE_TUP_", toString(m)).

	//// Complex type NmdTuple 
	NmdTup2ArrayInit ::= (type: NmdTupType, narr: out.Expr, tarr: out.Expr). 
	NmdTup2ArrayInit(t, narr, tarr) :- TranslatedTypeExpr(t), t = NmdTupType(NmdTupTypeField(n', t'), NIL), TypeConstant(t', id', _), 
	                                   tarr = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), NIL)), 
	                                   narr = Init(Args(StringLit(n', NIL), NIL)).
									    
	NmdTup2ArrayInit(t, narr, tarr) :- TranslatedTypeExpr(t), t = NmdTupType(NmdTupTypeField(n', t'), t''), TypeConstant(t', id', _), NmdTup2ArrayInit(t'', Init(n''), Init(ts'')), 
	                                   tarr = Init(Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(id')))), ts'')),
	                                   narr = Init(Args(StringLit(n', NIL), n'')).

	TypeConstant(t, m, defs) :- TypeId(m, t), TypeConstant(_, m - 1, before), NmdTup2ArrayInit(t, narr, tarr), t : NmdTupType, 
								     defs = out.Section(before, Section(defNmdTupNArr, Section(defNmdTupTArr, Section(defNmdTup, def)))),
										 defNmdTupNArr = out.VarDef(
										              NIL, 
															    ArrType(NmdType(NIL, "PRT_STRING"), NIL), 
															    typeNameNmdTupNArr, 
															    narr),
										 defNmdTupTArr = out.VarDef(
										              NIL, 
															    ArrType(PtrType(NmdType(NIL, "PRT_TYPE")), NIL), 
															    typeNameNmdTupTArr, 
															    tarr),
										 defNmdTup = out.VarDef(
										          NIL, 
														  NmdType(NIL, "PRT_NMDTUPTYPE"), 
														  typeNameNmdTup, 
														  Init(
														  Args(IntLit(lstLength(#NmdTupType, t), DEC, NIL), 
															Args(Ident(typeNameNmdTupNArr), 
															Args(Ident(typeNameNmdTupTArr), 
															NIL))))),
										 def = out.VarDef(
										         NIL, 
													   NmdType(NIL, "PRT_TYPE"), 
													   strJoin("P_GEND_TYPE_", toString(m)), 
													   typeStatic),
							       typeStatic = out.Init(
										      Args(Ident("PRT_KIND_NMDTUP"), 
											    Args(Init(Args(Cast(PtrType(NmdType(NIL, "PRT_MAPTYPE")), UnApp(ADDR, Ident(typeNameNmdTup))), NIL)),
											    NIL))),
										 typeNameNmdTupTArr = strJoin("P_GEND_TYPE_NMDTUP_TARR_", toString(m)),
										 typeNameNmdTupNArr = strJoin("P_GEND_TYPE_NMDTUP_NARR_", toString(m)),
										 typeNameNmdTup = strJoin("P_GEND_TYPE_NMDTUP_", toString(m)).

    COut(0, defs) :- TypeConstant(_, c, defs), defs : out.Section, c = count({ td | td is TypeId}) - 1.
    
	/*************************************************************/
    /******   Generate C statics for typedefs in program   ******/
    /*************************************************************/
	TypeToExpr ::= (TypeExpr, Expr).
	TypeToExpr(type, expr) :- TypeId(typeIndex, type), expr = out.UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(typeIndex)))).

	COut(1, def) :- TypeDef(name, type),
	                typeName = strJoin("P_GEND_TYPE_", name), TypeToExpr(type, expr),
					def = out.VarDef(NIL, PtrType(NmdType(NIL, "PRT_TYPE")), typeName, expr).
	COut(1, def) :- ModelType(name), type = NameType(name),
	                typeName = strJoin("P_GEND_TYPE_", name), TypeToExpr(type, expr),
					def = out.VarDef(NIL, PtrType(NmdType(NIL, "PRT_TYPE")), typeName, expr).


	/*************************************************************/
    /******            Generate event decls                 ******/
    /*************************************************************/	
	EvDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	EvDecl2PayloadType ::= (EventDecl, out.Expr).
	//// An EventDecl without a payload type has a null payload type.
	EvDecl2PayloadType(d, expr) :- d is EventDecl(_, _, NIL), TypeToExpr(in.BaseType(NULL), expr).
	//// An EventDecl with a payload type refers to one of the statically generated types.
	EvDecl2PayloadType(d, expr) :- d is EventDecl(_, _, type), type : TypeExpr, TypeToExpr(type, expr).

	EvDecl2EvCard      ::= (EventDecl, out.Expr).
	//// An EventDecl without a queue constraint allows 2^32 - 1 events in a queue.
	EvDecl2EvCard(d, e) :- d is EventDecl(_, NIL, _), e = IntLit(4294967295, DEC, U).
	//// An EventDecl with a payload type refers to one of the statically generated types.
	EvDecl2EvCard(d, e) :- d is EventDecl(_, card, _), e = IntLit(card.bound, DEC, U).

	//// Base case
	EvDeclConcat(c, NIL) :- c = count({d | d is EventDecl}) + 2.

    //// Build event array in reverse order
	EvDeclConcat(m, arr) :- DeclId(d, m, cn), EvDeclConcat(m + 1, after), arr = out.Args(def, after), EvDecl2PayloadType(d, expr), EvDecl2EvCard(d, card), 
	                        def = Init(
							   Args(Ident(cn),
							   Args(StringLit(d.name, NIL),
							   Args(card,
							   Args(expr,
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

	//// Define the halt event
	EvDeclConcat(1, arr) :- EvDeclConcat(2, after), arr = out.Args(def, after), TypeConstant(in.BaseType(ANY), typeId, _),
	                        def = Init(
							   Args(Ident("_P_EVENT_HALT"),
							   Args(StringLit("halt", NIL),
							   Args(IntLit(4294967295, DEC, U),
							   Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(typeId)))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

	//// Define the default event
	EvDeclConcat(0, arr) :- EvDeclConcat(1, after), arr = out.Args(def, after), TypeConstant(in.BaseType(NULL), typeId, _),
	                        def = Init(
							   Args(Ident("_P_EVENT_NULL"),
							   Args(StringLit("null", NIL),
							   Args(IntLit(0, DEC, U),
							   Args(UnApp(ADDR, Ident(strJoin("P_GEND_TYPE_", toString(typeId)))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))).

    //// Emit the event decl array.
	COut(2, def) :- EvDeclConcat(0, arr), 
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_EVENTDECL"), NIL), 
								  "P_GEND_EVENTS", 
								  Init(arr)).

    /*************************************************************/
    /******         Generate EventSet Decl Arrays           ******/
    /*************************************************************/	
	EventPackList ::= (dat: EventPackData, tl: EventPackList + { NIL }).
	EventPackData ::= (arrIndex: Natural, events: Natural). 
	EventPacking  ::= (list: EventNameList + { NIL }, rem: EventPackList + { NIL }, arrIndex: Natural, packArr: out.Args + { NIL }).

	EventId ::= (trig: String + { NULL, HALT }, id: Natural).
	EventId(trig, id) :- trig : String, ev is EventDecl, ev.name = trig, DeclId(ev, id, _).
	EventId(NULL, id) :- DeclId(NULL, id, _).
	EventId(HALT, id) :- DeclId(HALT, id, _).

	EventSetId ::= (EventSet, EventNameList + { NIL }, EventName, Natural).
	EventSetId(eventset, list, ev, id) :- eventset is EventSet(_, EventNameList(ev, list)), EventId(ev, id).
	EventSetId(eventset, list, ev, id) :- EventSetId(eventset, EventNameList(ev, list), _, _), EventId(ev, id).

	EventPacking(eventset.list, rlist, size, NIL) :- 
		 eventset is EventSet,
		 list = toList(
		           #EventPackList, 
				   NIL, 
				   { EventPackData(i, n) | 
				        EventSetId(eventset, _, _, j), i = qtnt(j / 32, 1), 
				        n = sum(0, { m | EventSetId(eventset, _, _, k), i = qtnt(k / 32, 1), PowOf2(k % 32, m) }), n : Natural 
	               }),
		 rlist = lstReverse(#EventPackList, list),
		 highestEventIndex = 1 + count({decl | decl is EventDecl}), size = 1 + qtnt(highestEventIndex / 32, 1), size: Natural.

    //// Build up pack array.
	EventPacking(l, NIL, i', a') :- EventPacking(l, NIL, i, a), i > 0, i' = i - 1, i' : Natural, a' = Args(IntLit(0, HEX, U), a).
	EventPacking(l, r, i', a') :- EventPacking(l, r, i, a), i > 0, i' = i - 1, i' : Natural, r.dat.arrIndex < i', a' = Args(IntLit(0, HEX, U), a).
	EventPacking(l, r.tl, i', a') :- EventPacking(l, r, i, a), i > 0, i' = i - 1, i' : Natural, r.dat.arrIndex = i', a' = Args(IntLit(r.dat.events, HEX, U), a).

	COut(3, def) :- EventPacking(l, _, 0, a),
	                id = toOrdinal(l, 0, { l' | EventPacking(l', _, 0, _) }),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_UINT32"), NIL), 
								  strJoin("P_GEND_EVENTSET_", toString(id)), 
								  Init(a)).

    //// Build up event sets.
	EvSetDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	//// Base case
	EvSetDeclConcat(c, NIL) :- c = count({l | EventPacking(l, _, 0, _) }).

    //// Build every event set array in reverse order
	EvSetDeclConcat(m, arr) :- 
	                        EventPacking(l, _, _, NIL),
	                        m = toOrdinal(l, 0, { l' | EventPacking(l', _, 0, _) }),
							EvSetDeclConcat(m + 1, after),							  
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(IntLit(m, DEC, NIL),
							   Args(Ident(strJoin("P_GEND_EVENTSET_", toString(m))),
							   NIL))).

	COut(4, def) :- EvSetDeclConcat(0, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_EVENTSETDECL"), NIL), 
								  "P_GEND_EVENTSETS", 
								  Init(arr)).

    /*************************************************************/
    /******          Generate Global Fun Decl Array         ******/
    /*************************************************************/
	COut(4, def) :-			init = Init(
							   Args(Ident("_P_FUN_PUSH_OR_IGN"),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   Args(Ident("NULL"),
							   Args(IntLit(1, DEC, U),
							   Args(IntLit(0, DEC, U),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   Args(Ident("NULL"),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL)))))))))))))),
							def = out.VarDef(
							      NIL, 
								  NmdType(NIL, "PRT_FUNDECL"), 
								  "P_FUN_IGNORE_PUSH_STRUCT", 
								  init).
	
   	FunDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	FunDeclConcat(c, NIL) :- c = 1 + count({d | d is AnonOrNamedFun }).

	FunDeclConcat(m, arr) :-  
							DeclId(d, m, cn), FunDeclConcat(m + 1, after), d : AnonOrNamedFun,
							funStructName = strJoin(cn, "_STRUCT"),
							arr = out.Args(def, after),
							def = UnApp(ADDR, Ident(funStructName)).

	//// Reserve the zeroth decl for the ignore/push transition
	FunDeclConcat(0, arr) :- FunDeclConcat(1, after), arr = out.Args(def, after), def = UnApp(ADDR, Ident("P_FUN_IGNORE_PUSH_STRUCT")).

	COut(5, def) :- FunDeclConcat(0, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(PtrType(NmdType(NIL, "PRT_FUNDECL")), NIL), 
								  "P_GEND_FUNS", 
								  Init(arr)).

    /*************************************************************/
    /******          Generate Machine Decl Arrays           ******/
    /*************************************************************/	
	MachineDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).
	MachineDeclConcat(c, NIL) :- c = count({m | m is MachineDecl}).
	MachineDeclConcat(m, arr) :- 
							DeclId(d, m, _), d : MachineDecl, 
							machineName = strJoin("P_MACHINE_", d.name), machineStructName = strJoin(machineName, "_STRUCT"),
							MachineDeclConcat(m + 1, after),  
							arr = out.Args(def, after),
							def = UnApp(ADDR, Ident(machineStructName)).

	COut(5, def) :- MachineDeclConcat(0, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(PtrType(NmdType(NIL, "PRT_MACHINEDECL")), NIL), 
								  "P_GEND_MACHINES", 
								  Init(arr)).

    /*************************************************************/
    /******     Generate Foreign Type Decl Arrays           ******/
    /*************************************************************/	
	ForeignTypeDeclConcat ::= (pos: Natural, arr: out.Args + {NIL}).

	//// Base case
	ForeignTypeDeclConcat(c, NIL) :- c = count({name | ModelType(name)}).

	ForeignTypeDeclConcat(m, arr) :- 
							ModelType(name), m = toOrdinal(name, 0, { n | ModelType(n) }),
							ForeignTypeDeclConcat(m + 1, after),  
							arr = out.Args(def, after), 
	                        def = Init(
							   Args(Ident(strJoin("P_FORGN_TYPE_", name)),
							   Args(StringLit(name, NIL),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_MKDEF_", strJoin(name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_CLONE_", strJoin(name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_FREE_", strJoin(name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_GETHASHCODE_", strJoin(name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_ISEQUAL_", strJoin(name, "_IMPL")))),
							   Args(UnApp(ADDR, Ident(strJoin("PRT_FORGN_TOSTRING_", strJoin(name, "_IMPL")))),
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))))))).

	COut(5, def) :- ForeignTypeDeclConcat(0, arr),
	                def = out.VarDef(
							      NIL, 
								  ArrType(NmdType(NIL, "PRT_FOREIGNTYPEDECL"), NIL), 
								  "P_GEND_FOREIGNTYPES", 
								  Init(arr)).

    /*************************************************************/
    /******            Generate Program Decl                ******/
    /*************************************************************/	

	ProgEvntArray ::= (size: Natural, arr: out.Ident).
	ProgEvntArray(size, arr) :- size = 2 + count({ e | e is EventDecl }), arr = out.Ident("P_GEND_EVENTS").

	ProgEvntSetArray ::= (size: Natural, arr: out.Ident).
	ProgEvntSetArray(size, arr) :- size = count({ l | EventPacking(l, _, 0, _) }), size = 0, arr = out.Ident("NULL").
	ProgEvntSetArray(size, arr) :- size = count({ l | EventPacking(l, _, 0, _) }), size > 0, arr = out.Ident("P_GEND_EVENTSETS").

	ProgMachArray ::= (size: Natural, arr: out.Ident).
	ProgMachArray(size, arr) :- size = count({ m | m is MachineDecl }), size = 0, arr = out.Ident("NULL").
	ProgMachArray(size, arr) :- size = count({ m | m is MachineDecl }), size > 0, arr = out.Ident("P_GEND_MACHINES").

	ProgGlobalFunArray ::= (size: Natural, arr: out.Ident).
	ProgGlobalFunArray(size, arr) :- size = 1 + count({ m | m is AnonOrNamedFun }), arr = out.Ident("P_GEND_FUNS").

	ProgForeignTypesArray ::= (size: Natural, arr: out.Ident).
	ProgForeignTypesArray(size, arr) :- size = count({ n | ModelType(n) }), size = 0, arr = out.Ident("NULL").
	ProgForeignTypesArray(size, arr) :- size = count({ n | ModelType(n) }), size > 0, arr = out.Ident("P_GEND_FOREIGNTYPES").

	COut(6, def) :-  ProgEvntArray(evArrSize, evArrName),
	                 ProgEvntSetArray(evSetArrSize, evSetArrName),
					 ProgMachArray(machArrSize, machArrName),
					 ProgGlobalFunArray(globalFunArrSize, globalFunArrName),
					 ProgForeignTypesArray(foreignTypesSize, foreignTypesArrName),
	                 def = out.VarDef(
							      NIL, 
								  NmdType(NIL, "PRT_PROGRAMDECL"), 
								  "P_GEND_PROGRAM", 
								  init),
				     init = Init(
							   Args(IntLit(evArrSize, DEC, U),
							   Args(IntLit(evSetArrSize, DEC, U),
							   Args(IntLit(machArrSize, DEC, U),
							   Args(IntLit(globalFunArrSize, DEC, U),
							   Args(IntLit(foreignTypesSize, DEC, U),
							   Args(evArrName,
							   Args(evSetArrName,
							   Args(machArrName,
							   Args(globalFunArrName,
							   Args(foreignTypesArrName,
							   Args(IntLit(0, DEC, U),
							   Args(Ident("NULL"),
							   NIL))))))))))))).

	/*************************************************************/
    /******                 Powers of two                   ******/
    /*************************************************************/	

	PowOf2 ::= (exp: {0..31}, val: Natural).

	PowOf2(0, 1).          PowOf2(1, 2).          PowOf2(2, 4).           PowOf2(3, 8).
	PowOf2(4, 16).         PowOf2(5, 32).         PowOf2(6, 64).          PowOf2(7, 128).
	PowOf2(8, 256).        PowOf2(9, 512).        PowOf2(10, 1024).       PowOf2(11, 2048).
	PowOf2(12, 4096).      PowOf2(13, 8192).      PowOf2(14, 16384).      PowOf2(15, 32768).
	PowOf2(16, 65536).     PowOf2(17, 131072).    PowOf2(18, 262144).     PowOf2(19, 524288).
	PowOf2(20, 1048576).   PowOf2(21, 2097152).   PowOf2(22, 4194304).    PowOf2(23, 8388608).
	PowOf2(24, 16777216).  PowOf2(25, 33554432).  PowOf2(26, 67108864).   PowOf2(27, 134217728).
	PowOf2(28, 268435456). PowOf2(29, 536870912). PowOf2(30, 1073741824). PowOf2(31, 2147483648).

}