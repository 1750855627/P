[
   modules.P     = '"P     at ..\Domains\P.4ml"',
   modules.PData = '"PData at ..\Domains\P.4ml"'
]

domain PWithInferredTypes extends PData
{
    //// The declarations that may contain expressions or statements that should be typed.
    TypingContext ::= FunDecl + AnonFunDecl.
    
    //// The set of typeable expressions and statements.
    Typeable ::= Expr + Stmt + Exprs + NamedExprs + Cases.
    
    //// The type judgement. NIL is a placeholder for untyped constructs.
    TypeOf ::= new (cntxt: any TypingContext, expr: any Typeable, type: any TypeExpr + { ERROR, NIL }).

	//// The maximum number of local variables in any context
	MaxNumLocals ::= new (ctxt: TypingContext + Stmt + Cases, n: Natural).

	//// The map from interface type to the machine implementing it for a given module-list
	InterfaceToMachineMap ::= new (ml: ModuleList, i: InterfaceType, m: MachineDecl).

	//// The map from module to the hidden events in the module for a given module-list
	HiddenEvents ::= new (mdl: ModuleList, md: ModuleDecl, evl : EventList + {NIL}).
}

transform P2PWithInferredTypes (in:: P) returns (out:: PWithInferredTypes)
{
    out._(x) :- x is in.Data.
	out.TypeOf(c, e, t) :- in.TypeOf(c, e, t).
	out.MaxNumLocals(c, n) :- in.MaxNumLocals(c, n).
	out.InterfaceToMachineMap(ml, i, m) :- in.InterfaceToMachineMap(ml, i, m). 
	out.HiddenEvents(ml, m, evl) :- in.HiddenEvents(ml, m, evl).
}
