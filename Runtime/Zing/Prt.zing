class SM_NULL { };

class MachineId
{
	static int nextMachineId = 0;

	static int GetNextId()
	{
		int ret = nextMachineId;
		nextMachineId = nextMachineId + 1;
		return ret;
	}
};

class SM_EVENT {    
    Event name;
    int maxInstances;
	bool doAssume;

    static SM_EVENT Construct(Event name, int mInstances, bool doAssume) {
		SM_EVENT smEvent = new SM_EVENT;
		smEvent.name = name;
		smEvent.maxInstances = mInstances;
		smEvent.doAssume = doAssume;
		return smEvent;
    }
};

set SM_EVENT_SET SM_EVENT;

class SPEC_HANDLE {
	Machine machineName;
	int instance;
	SM_EVENT currentEvent;
        PRT_VALUE currentArg;

    static SPEC_HANDLE Construct(Machine mName, int inst) {
    	SPEC_HANDLE handle;
		handle = new SPEC_HANDLE;
		handle.machineName = mName;
		handle.instance = inst;
		handle.currentEvent = null;
		handle.currentArg = PRT_VALUE.PrtMkDefaultValue();
		trace("<CreateLog> Created Machine {0}-{1}", handle.machineName, handle.instance);
		return handle;
    }
};

class SM_HANDLE {
    EVENT_BUFFER buffer;
	int maxBufferSize;
	Machine machineName;
	int machineId;
	int instance;
	SM_EVENT currentEvent;
    PRT_VALUE currentArg;
    bool blocked;
	bool isDeleted;
	
    static SM_HANDLE Construct(Machine mName, int inst, int maxBSize) {
    	SM_HANDLE handle;
		handle = new SM_HANDLE;
		handle.machineName = mName;
		handle.instance = inst;
		handle.buffer = EVENT_BUFFER.Construct();
		handle.currentEvent = null;
		handle.currentArg = PRT_VALUE.PrtMkDefaultValue();
		handle.maxBufferSize = maxBSize;
		handle.blocked = false;
		handle.isDeleted = false;
		trace("<CreateLog> Created Machine {0}-{1}", handle.machineName, handle.instance);
		return handle;
    }

    void EnqueueEvent(SM_EVENT e, PRT_VALUE arg, SM_HANDLE source) {
    	assert (e != null);
		assert (e != Main.default_SM_EVENT);
		if(isDeleted)
		{
			trace("<EnqueueLog> {0}-{1} Machine has been deleted and  Event {2} is dropped", machineName, instance, e.name);
			
		}
		else
		{
			if (arg != null)
			{
				if (arg.d == Discriminator.Bool)
					trace("<EnqueueLog> Enqueued Event < {0}, bool: {1} > in Machine {2}-{3} by {4}-{5}", e.name, arg.m_Bool, machineName, instance, source.machineName, source.instance);
				else if(arg.d == Discriminator.Int)
					trace("<EnqueueLog> Enqueued Event < {0}, Int: {1} > in Machine {2}-{3} by {4}-{5}", e.name, arg.m_Int, machineName, instance, source.machineName, source.instance);
				else if (arg.d == Discriminator.Id)
					trace("<EnqueueLog> Enqueued Event < {0}, Handle: {1}-{2} > in Machine {3}-{4} by {5}-{6}", e.name, arg.m_Id.machineName, arg.m_Id.instance, machineName, instance, source.machineName, source.instance);
				else if (arg.d == Discriminator.Mid)
					trace("<EnqueueLog> Enqueued Event < {0}, Handle: {1}-{2} > in Machine {3}-{4} by {5}-{6}", e.name, arg.m_Mid.machineName, arg.m_Mid.instance, machineName, instance, source.machineName, source.instance);
				else
					trace("<EnqueueLog> Enqueued Event < {0}, Other: > in Machine {1}-{2} by {3}-{4}", e.name, machineName, instance, source.machineName, source.instance);
			}
			else
			{
				trace("<EnqueueLog> Enqueued Event < {0} > in Machine {1}-{2} by {3}-{4}", e.name, machineName, instance, source.machineName, source.instance);
			}

			buffer.EnqueueEvent(e, arg);
			if (maxBufferSize != -1 && buffer.eventBufferSize > maxBufferSize)
			{
				trace("<EXCEPTION> Event Buffer Size Exceeded {0} in Machine {1}-{2}", maxBufferSize, machineName, instance);
				assert(false);
			}
			blocked = false;
			invokescheduler("push", machineId);
		}
    }
	
    void DequeueEvent(bool hasDefault, SM_EVENT_SET deferredSet, bool stable) {
		currentEvent = null;
		currentArg = null;
		while (currentEvent == null) {
			buffer.DequeueEvent(deferredSet, this);
			if (currentEvent != null) 
			{
				assert(currentArg != null);
				if (currentArg.d == Discriminator.Bool)
					trace("<DequeueLog> Dequeued Event < {0}, Bool: {1} > at Machine {2}-{3}", currentEvent.name, currentArg.m_Bool, machineName, instance);
				else if (currentArg.d == Discriminator.Int)
					trace("<DequeueLog> Dequeued Event < {0}, Int: {1} > at Machine {2}-{3}", currentEvent.name, currentArg.m_Int, machineName, instance);
				else if (currentArg.d == Discriminator.Mid)
					trace("<DequeueLog> Dequeued Event < {0}, Handle: {1}-{2} > at Machine {3}-{4}", currentEvent.name, currentArg.m_Mid.machineName, currentArg.m_Mid.instance, machineName, instance);
				else if (currentArg.d == Discriminator.Eid)
					trace("<DequeueLog> Dequeued Event < {0}, Event: {1} > at Machine {2}-{3}", currentEvent.name, currentArg.m_Eid, machineName, instance);
				else if (currentArg.d == Discriminator.Null)
					trace("<DequeueLog> Dequeued Event < {0}, Null Payload > at Machine {1}-{2}", currentEvent.name, machineName, instance);
				else
					trace("<DequeueLog> Dequeued Event < {0}, Other: > at Machine {1}-{2}", currentEvent.name, machineName, instance);
				blocked = false;
			} 
			else if (hasDefault) 
			{
				trace("<DefaultTransLog> Default transition taken by Machine {0}-{1}", machineName, instance);
	            currentEvent = Main.default_SM_EVENT;
				blocked = false;
				FairScheduler.AtYieldStatic(this);
				FairChoice.AtYieldOrChooseStatic();
				yield;
			} 
			else 
			{
  				invokescheduler("pop");
				assume (!blocked);
				if (stable) { blocked = true; }
				FairScheduler.AtYieldStatic(this);
				FairChoice.AtYieldOrChooseStatic();
				yield;
			}
        }
    }
};

class EVENT_NODE {
    EVENT_NODE next;
    EVENT_NODE prev;
    SM_EVENT e;
	PRT_VALUE arg;
};

class EVENT_BUFFER {
    EVENT_NODE head;
	int eventBufferSize;
    static EVENT_BUFFER Construct() {
        EVENT_BUFFER buffer;
		EVENT_NODE head;
    	head = new EVENT_NODE;
    	head.next = head;
    	head.prev = head;
    	head.e = null;
    	buffer = new EVENT_BUFFER; 
		buffer.head = head;
		buffer.eventBufferSize = 0;
		return buffer;
    }

    int CalculateInstances(SM_EVENT e) {
        EVENT_NODE elem;
		int currInstances;
		currInstances = 0;
        elem = head.next;
        while (elem != head) {
            if (elem.e.name == e.name) {
				currInstances = currInstances + 1;
			}
			elem = elem.next;
        }
		assert (currInstances <= e.maxInstances);
		return currInstances;
    }
	

    void EnqueueEvent(SM_EVENT e, PRT_VALUE arg) {
        EVENT_NODE elem;
		int currInstances;
	
		if (e.maxInstances == -1)
		{
			elem = new EVENT_NODE;
			elem.e = e;
			elem.arg = arg;
			elem.prev = head.prev;
			elem.next = head;
			elem.prev.next = elem;    
			elem.next.prev = elem;
			eventBufferSize = eventBufferSize + 1;
		}
		else
		{
			currInstances = CalculateInstances(e);
			if (currInstances == e.maxInstances)
			{
				if (e.doAssume)
				{
					assume(false);
				}
				else
				{
					trace("<Exception> Attempting to enqueue event {0} more than max instance of {1}", e.name, e.maxInstances);
					assert(false);
				}
			}
			else
			{
    			elem = new EVENT_NODE;
    			elem.e = e;
				elem.arg = arg;
    			elem.prev = head.prev;
    			elem.next = head;
    			elem.prev.next = elem;    
    			elem.next.prev = elem;
				eventBufferSize = eventBufferSize + 1;
			}
		}
	}

    void DequeueEvent(SM_EVENT_SET deferredSet, SM_HANDLE owner) {
        EVENT_NODE iter;
		
        iter = head.next;
        while (iter != head) {
			if (iter.e in deferredSet)
			{
				iter = iter.next;
			}
			else 
			{
				iter.next.prev = iter.prev;
				iter.prev.next = iter.next;
				owner.currentEvent = iter.e;
				owner.currentArg = iter.arg;
				eventBufferSize = eventBufferSize - 1;
				return;
			} 
        }
		return;
    }
};

array SM_EVENT_array[] SM_EVENT;
array ActionFun_array[] ActionFun;

class LocalActions {
    SM_EVENT_array es;
    ActionFun_array as;
    LocalActions next;

    ActionFun Find(SM_EVENT f) {
        ActionFun af;
        int i = 0;
		while (i < sizeof(es)) {
			if (es[i] == f) {
				return as[i];
			} else {
				i = i + 1;
			}
		}
		af = next.Find(f);
		return af;
    }

    static LocalActions Construct(LocalActions nextElem) {
        LocalActions localActions;
		localActions = new LocalActions;
		localActions.next = nextElem;
		return localActions;
    }
};

enum ContinuationReason { Return, Nondet, Pop, Raise, Call, Send, NewMachine };

class StackFrame {
    int pc;
    StackFrame next;
};

class Continuation {
    StackFrame returnTo;
    ContinuationReason reason;
    State state;
    bool nondet;
    SM_HANDLE id;

    static Continuation Construct_Default() {
        Continuation res;
	res = new Continuation;
	res.returnTo = null;
	res.reason = ContinuationReason.Return;
	res.state = State._default;
	res.nondet = false;
	res.id = null;
	return res;
    }

    int PopReturnTo() {
        int res;
	res = this.returnTo.pc;
	this.returnTo = this.returnTo.next;
	return res;
    }

    void PushReturnTo(int ret) {
        StackFrame tmp;
	tmp = new StackFrame;
	tmp.pc = ret;
	tmp.next = this.returnTo;
	this.returnTo = tmp;
    }

    void Return() {
        this.returnTo = null;
	this.reason = ContinuationReason.Return;
	this.state = State._default;
	this.id = null;
    }

    void Pop() {
        this.returnTo = null;
	this.reason = ContinuationReason.Pop;
	this.state = State._default;
	this.id = null;
    }

    void Raise() {
        this.returnTo = null;
	this.state = State._default;
	this.reason = ContinuationReason.Raise;
	this.id = null;
    }

    void Send(int ret) {
        this.returnTo = null;
	this.reason = ContinuationReason.Send;
	this.state = State._default;
	this.id = null;
	this.PushReturnTo(ret);
    }

    void NewMachine(int ret, SM_HANDLE o) {
        this.returnTo = null;
	this.reason = ContinuationReason.NewMachine;
	this.state = State._default;
	this.id = o;
	this.PushReturnTo(ret);
    }

    void Call(int ret, State state) {
        this.returnTo = null;
	this.reason = ContinuationReason.Call;
	this.state = state;
	this.id = null;
	this.PushReturnTo(ret);
    }

    void Nondet(int ret) {
        this.returnTo = null;
	this.reason = ContinuationReason.Nondet;
	this.state = State._default;
	this.id = null;
	this.PushReturnTo(ret);
    }
};

// Add an instance of FairScheduler per running P machine.
// Add an instance of FairChoice per running P machine and fair choice in that machine.
// Invoke FairScheduler.AtYieldStatic and FairChoice.AtYieldOrChooseStatic at each yield.
// Invoke FairScheduler.AtChooseStatic and FairChoice.AtYieldOrChooseStatic at each choose.
set FairSchedulers FairScheduler;
class FairScheduler {      
    SM_HANDLE handle;
    static bool noYieldFromNowOn = false;

    static void Init(FairScheduler fs, SM_HANDLE h) {
	fs.handle = h;
	all = all + fs;
    }

    void AtYield(SM_HANDLE running) {
		assume (!noYieldFromNowOn);
		if (running == handle || handle.blocked) {
		   FairScheduler.accepted = FairScheduler.accepted + this;
		   FairCycle.Accept();
		}
    }

    void AtChoose() {
	    if (!noYieldFromNowOn) {
			noYieldFromNowOn = choose(bool);
		}
		if (noYieldFromNowOn) {
		   FairScheduler.accepted = FairScheduler.accepted + this;
		   FairCycle.Accept();
		}
    }

    static FairSchedulers all = new FairSchedulers;
    static FairSchedulers accepted = new FairSchedulers;

    static void AtYieldStatic(SM_HANDLE running) {
	foreach (FairScheduler m in all) {
		m.AtYield(running);
	}
    }

    static void AtChooseStatic() {
	foreach (FairScheduler m in all) {
		m.AtChoose();
	}
    }
};

set FairChoices FairChoice;
class FairChoice {
    bool lastChoice;

    static void Init(FairChoice fs) {
	fs.lastChoice = false;
	all = all + fs;
    }

    void AtYieldOrChoose() {
        bool b;
	b = choose(bool);
      	if (b) {
	    FairChoice.all = FairChoice.all - this;
	}
    }
    
    void AtChoose(bool b) {
        assume (this in FairChoice.all);
        if (b != lastChoice) {
	    lastChoice = b;
	    FairChoice.accepted = FairChoice.accepted + this;
	    FairCycle.Accept();
	}
    }

    static FairChoices all = new FairChoices;
    static FairChoices accepted = new FairChoices;

    static void AtYieldOrChooseStatic() {
	foreach (FairChoice m in all) {
	    m.AtYieldOrChoose();
	}
    }
};

enum GateStatus { Init, Selected, InStable, Closed };

class FairCycle {
    static GateStatus gate = GateStatus.Init;
    static void Accept() {
        if (gate == GateStatus.Closed &&
	    sizeof(FairChoice.accepted) == sizeof(FairChoice.all) && 
       	    sizeof(FairScheduler.accepted) == sizeof(FairScheduler.all))
	{
	    trace("Accepting transition");
	    accept(true);
      	    FairChoice.accepted = new FairChoices;
	    FairScheduler.accepted = new FairSchedulers;
	}	
    }
};