class SM_NULL { };

class MachineId
{
	static int nextMachineId = 0;

	static int GetNextId()
	{
		int ret = nextMachineId;
		nextMachineId = nextMachineId + 1;
		return ret;
	}
};

class SM_EVENT {    
    Event name;
    int maxInstances;
	bool doAssume;
    static SM_EVENT Construct(Event name, int mInstances, bool doAssume) {
      SM_EVENT smEvent = new SM_EVENT;
      smEvent.name = name;
      smEvent.maxInstances = mInstances;
	  smEvent.doAssume = doAssume;
      return smEvent;
    }
};

set SM_EVENT_SET SM_EVENT;

class SM_HANDLE {
    EVENT_BUFFER buffer;
	int maxBufferSize;
	Machine machineName;
	int machineId;
	int instance;
	SM_EVENT currentEvent;
    SM_ARG_UNION currentArg;
    static SM_HANDLE Construct(Machine mName, int inst, int maxBSize) {
    	SM_HANDLE handle;
		handle = new SM_HANDLE;
		handle.machineName = mName;
		handle.instance = inst;
		handle.buffer = EVENT_BUFFER.Construct();
		handle.currentEvent = null;
		handle.currentArg = SM_ARG_UNION.BuildDefault();
		handle.maxBufferSize = maxBSize;
		trace("<CreateLog> Created Machine {0}-{1}", handle.machineName, handle.instance);
		return handle;
    }

    void EnqueueEvent(SM_EVENT e, SM_ARG_UNION arg, SM_HANDLE source) {
    	assert (e != null);
		assert (e != Main.default_SM_EVENT);

		if(maxBufferSize != -1 && buffer.eventBufferSize >= maxBufferSize)
		{
			trace("<EXCEPTION> Event Buffer Size Exceeded {0} in Machine {1}-{2}", maxBufferSize, machineName, instance);
			assert(buffer.eventBufferSize < maxBufferSize);
		}
		if(arg != null)
		{
		if(arg.d == Discriminator.Bool)
		trace("<EnqueueLog> Enqueued Event < {0}, bool: {1} > in Machine {2}-{3} by {4}-{5}", e.name, arg.m_Bool, machineName, instance, source.machineName, source.instance);
		else if(arg.d == Discriminator.Int)
		trace("<EnqueueLog> Enqueued Event < {0}, Int: {1} > in Machine {2}-{3} by {4}-{5}", e.name, arg.m_Int, machineName, instance, source.machineName, source.instance);
		else if (arg.d == Discriminator.Mid)
		trace("<EnqueueLog> Enqueued Event < {0}, Handle: {1}-{2} > in Machine {3}-{4} by {5}-{6}", e.name, arg.m_Mid.machineName, arg.m_Mid.instance, machineName, instance, source.machineName, source.instance);
		else
		trace("<EnqueueLog> Enqueued Event < {0}, Other: > in Machine {1}-{2} by {3}-{4}", e.name, machineName, instance, source.machineName, source.instance);
		}
		else
		{
		trace("<EnqueueLog> Enqueued Event < {0} > in Machine {1}-{2} by {3}-{4}", e.name, machineName, instance, source.machineName, source.instance);
		}

		buffer.EnqueueEvent(e, arg);
		SM_MONITORS.ProcessEnqueue(e, source, this);
		invokescheduler("push", machineId);
    }
	
    void DequeueEvent(bool hasDefault, SM_EVENT_SET deferredSet) {
		currentEvent = null;
		currentArg = null;
		while (currentEvent == null) {
	    buffer.DequeueEvent(deferredSet, this);
			if (currentEvent != null) {
				assert(currentArg != null);
		if(currentArg.d == Discriminator.Bool)
		trace("<DequeueLog> Dequeued Event < {0}, Bool: {1} > at Machine {2}-{3}", currentEvent.name, currentArg.m_Bool, machineName, instance);
		else if(currentArg.d == Discriminator.Int)
		trace("<DequeueLog> Dequeued Event < {0}, Int: {1} > at Machine {2}-{3}", currentEvent.name, currentArg.m_Int, machineName, instance);
		else if (currentArg.d == Discriminator.Mid)
		trace("<DequeueLog> Dequeued Event < {0}, Handle: {1}-{2} > at Machine {3}-{4}", currentEvent.name, currentArg.m_Mid.machineName, currentArg.m_Mid.instance, machineName, instance);
		else if (currentArg.d == Discriminator.Eid)
		trace("<DequeueLog> Dequeued Event < {0}, Event: {1} > at Machine {2}-{3}", currentEvent.name, currentArg.m_Eid, machineName, instance);
		else if (currentArg.d == Discriminator.Null)
		trace("<DequeueLog> Dequeued Event < {0}, Null Payload > at Machine {1}-{2}", currentEvent.name, machineName, instance);
		else
		trace("<DequeueLog> Dequeued Event < {0}, Other: > at Machine {1}-{2}", currentEvent.name, machineName, instance);
		SM_MONITORS.ProcessDequeue(currentEvent, this);
	    } else {
		if (hasDefault) {
		    trace("<DefaultTransLog> Default transition taken by Machine {0}-{1}", machineName, instance);
	            currentEvent = Main.default_SM_EVENT;
		} else {
  		    invokescheduler("pop");
		}
		yield;
	    }
        }
    }
};

class EVENT_NODE {
    EVENT_NODE next;
    EVENT_NODE prev;
    SM_EVENT e;
	SM_ARG_UNION arg;
};

class EVENT_BUFFER {
    EVENT_NODE head;
	int eventBufferSize;
    static EVENT_BUFFER Construct() {
        EVENT_BUFFER buffer;
		EVENT_NODE head;
    	head = new EVENT_NODE;
    	head.next = head;
    	head.prev = head;
    	head.e = null;
    	buffer = new EVENT_BUFFER; 
		buffer.head = head;
		buffer.eventBufferSize = 0;
		return buffer;
    }

    int CalculateInstances(SM_EVENT e) {
        EVENT_NODE elem;
	int currInstances;
	currInstances = 0;
        elem = head.next;
        while (elem != head) {
            if (elem.e.name == e.name) {
		currInstances = currInstances + 1;
	    }
	    elem = elem.next;
        }
	assert (currInstances <= e.maxInstances);
	return currInstances;
    }
	

    void EnqueueEvent(SM_EVENT e, SM_ARG_UNION arg) {
        EVENT_NODE elem;
	int currInstances;
	
	if(e.maxInstances == -1)
	{
		elem = new EVENT_NODE;
		elem.e = e;
		elem.arg = arg;
		elem.prev = head.prev;
		elem.next = head;
		elem.prev.next = elem;    
		elem.next.prev = elem;
		eventBufferSize = eventBufferSize + 1;
	}
	else
	{
		currInstances = CalculateInstances(e);
		if (currInstances == e.maxInstances)
		{
				if (e.doAssume)
				{
				assume(false);
			}
			else
			{
				trace("<Exception> Attempting to enqueue event {0} more than max instance of {1}", e.name, e.maxInstances);
				assert(false);
			}
		}
		else
		{
    			elem = new EVENT_NODE;
    			elem.e = e;
				elem.arg = arg;
    			elem.prev = head.prev;
    			elem.next = head;
    			elem.prev.next = elem;    
    			elem.next.prev = elem;
				eventBufferSize = eventBufferSize + 1;
		}
	}
	}

    void DequeueEvent(SM_EVENT_SET deferredSet, SM_HANDLE owner) {
        EVENT_NODE iter;
		
        iter = head.next;
        while (iter != head) {
			if (iter.e in deferredSet)
			{
				iter = iter.next;
			}
			else {
				iter.next.prev = iter.prev;
				iter.prev.next = iter.next;
				owner.currentEvent = iter.e;
				owner.currentArg = iter.arg;
				eventBufferSize = eventBufferSize - 1;
	            		return;
			} 
        }
	return;
    }

};

array SM_EVENT_array[] SM_EVENT;
array ActionFun_array[] ActionFun;

class LocalActions {
    SM_EVENT_array es;
    ActionFun_array as;
    LocalActions next;

    ActionFun Find(SM_EVENT f) {
        ActionFun af;
        int i = 0;
	while (i < sizeof(es)) {
	    if (es[i] == f) {
	        return as[i];
	    } else {
	        i = i + 1;
	    }
	}
	af = next.Find(f);
	return af;
    }

    static LocalActions Construct(LocalActions nextElem) {
        LocalActions localActions;
	localActions = new LocalActions;
	localActions.next = nextElem;
	return localActions;
    }
};

interface SM_MONITOR {
    bool IsInterestingEnqueue(SM_EVENT e, SM_HANDLE source, SM_HANDLE target);
    bool IsInterestingDequeue(SM_EVENT e, SM_HANDLE __self);
    void ProcessEnqueue(SM_EVENT e, SM_HANDLE source, SM_HANDLE target);
    void ProcessDequeue(SM_EVENT e, SM_HANDLE __self);
};

set SM_MONITOR_SET SM_MONITOR;

class SM_MONITORS {
    static SM_MONITOR_SET monitors = new SM_MONITOR_SET;

    static void Add(SM_MONITOR m) {
        monitors = monitors + m;
    }

    static void ProcessEnqueue(SM_EVENT e, SM_HANDLE source, SM_HANDLE target) {
        bool cond;
        foreach (SM_MONITOR m in monitors) {
	    cond = m.IsInterestingEnqueue(e, source, target);
	    if (cond) 
	        m.ProcessEnqueue(e, source, target);
	}
    }

    static void ProcessDequeue(SM_EVENT e, SM_HANDLE __self) {
        bool cond;
        foreach (SM_MONITOR m in monitors) {
	    cond = m.IsInterestingDequeue(e, __self);
	    if (cond) 
	        m.ProcessDequeue(e, __self);
	}
    }
};

enum ContinuationReason { Nondet, Leave, Return, ReturnVal, Raise, Call, Send, Delete, NewM};

class StackFrame {
    int pc;
    StackFrame next;
};
