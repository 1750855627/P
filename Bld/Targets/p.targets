<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <UnifiedPlatform>$(Platform)</UnifiedPlatform>
    <!-- C++ projects use "Win32" for "x86" platform and .NET projects use 'x86' -->
    <!-- So this new property unifies that difference and moves everything to 'x86' -->
    <UnifiedPlatform Condition="'$(Platform)'=='Win32'">x86</UnifiedPlatform>
    <DropFolder>$(MSBuildThisFileDirectory)..\Drops\$(Configuration)\$(UnifiedPlatform)</DropFolder>
    <CleanDependsOn>$(CleanDependsOn);CleanSdkHeaders;CleanClientFiles;CleanCompileP</CleanDependsOn>

    <!-- This is so that the C++ project will do incremental build of .p files correctly -->
    <DisableFastUpToDateCheck >True</DisableFastUpToDateCheck>
  </PropertyGroup>

  <UsingTask
    TaskName="CompareDates"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll">
    <ParameterGroup>
      <PCompile ParameterType="System.String" Required="true" />
      <PFiles ParameterType="System.String[]" Required="true" />
      <Result ParameterType="System.Boolean" Output="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System"/>
      <Using Namespace="System.IO"/>
      <Code Type="Fragment" Language="cs">
        <![CDATA[
        Result = false;
        if (!string.IsNullOrEmpty(PCompile)) {
          DateTime lastModified = File.GetLastWriteTime(PCompile);
          if (PFiles != null) {
            foreach (string pfile in PFiles)
            {
              DateTime pFileModified = File.GetLastWriteTime(pfile);
              if (pFileModified > lastModified) 
              {      
                Log.LogMessage(Path.GetFileName(pfile) + " is newer than " + Path.GetFileName(PCompile), MessageImportance.High);
                Result = true;
              }
            }
          }
        }
        ]]>
      </Code>
    </Task>
  </UsingTask>
  <Target Name="CheckPFiles" Inputs="@(PFile)" Outputs="%(RootDir)%(Directory)linker.c">

    <PropertyGroup>
      <PCompileTime>%(PCompile.ModifiedTime)</PCompileTime>
    </PropertyGroup>

    <CompareDates PCompile="@(PCompile)" PFiles="@(PFile)">
      <Output TaskParameter="Result" PropertyName="DateCompareResult" />
    </CompareDates>

    <!-- this will force a recompile of the PCompile file if any of the @(PFiles) are newer  -->
    <Delete Files="@(PCompile->'%(RootDir)%(Directory)linker.c')" Condition="'$(DateCompareResult)'=='true'" />
  </Target>

  <!-- this target it is tricky.  We want to have only one invocation of pc.exe passing just the list of p files
       that need to be recompiled, and not ALl of the @(PCompile) list, so this target creates that subset 
       using a clever ValueSetByTask trick documentated on https://msdn.microsoft.com/en-us/library/ee264087.aspx -->
  <Target Name="IncrementalCompileP" Inputs="@(PCompile);" 
          Outputs="%(RootDir)%(Directory)%(FileName).4ml;%(RootDir)%(Directory)%(FileName).c;%(RootDir)%(Directory)%(FileName).h;"
          BeforeTargets="BeforeBuildGenerateSources" DependsOnTargets="CheckPFiles">

    <Message Text="########## P file changed: @(PCompile) ##################" />

    <PropertyGroup>
      <WorkingDirs>@(PCompile->'%(RootDir)%(Directory)')</WorkingDirs>
      <WorkingDir>$(WorkingDirs.Split(';')[0])</WorkingDir>
    </PropertyGroup>
    <CreateItem Include="@(PCompile->'$(WorkingDir)\%(FileName).4ml')">
      <Output
          TaskParameter="Include"
          ItemName="PLink"/>
    </CreateItem>
    <CreateProperty Value="true">
      <Output TaskParameter="ValueSetByTask" PropertyName="CompileRan" />
    </CreateProperty>
    <!-- must always include the C file output in the final C++ compile -->
    <CreateItem Include="@(PCompile->'$(WorkingDir)%(FileName).c')">
      <Output
          TaskParameter="Include"
          ItemName="ClCompile"/>
    </CreateItem>
    <!-- but we conditionally create these items based on whether the compile should run or not -->
    <CreateItem Condition="'$(CompileRan)'=='True'" Include="@(PCompile)">
      <Output
          TaskParameter="Include"
          ItemName="PIncrementalCompile"/>
    </CreateItem>
    <CreateItem Condition="'$(CompileRan)'=='True'" Include="@(PCompile->'$(WorkingDir)%(FileName).c')">
      <Output
          TaskParameter="Include"
          ItemName="POutputC"/>
    </CreateItem>
    <CreateItem Condition="'$(CompileRan)'=='True'" Include="@(PCompile->'$(WorkingDir)%(FileName).h')">
      <Output
          TaskParameter="Include"
          ItemName="POutputH"/>
    </CreateItem>
    <CreateItem Condition="'$(CompileRan)'=='True'" Include="@(PCompile->'$(WorkingDir)%(FileName).4ml')">
      <Output
          TaskParameter="Include"
          ItemName="POutput4ml"/>
    </CreateItem>
  </Target>

  <!-- now that we have the restricted list of P files needed to be recompiled in PIncrementalCompile we can invoke pc.exe -->
  <Target Name="CompileP" Inputs="@(PIncrementalCompile)" Outputs="@(POutputC);@(POutputH);@(POutput4ml);%(RootDir)%(Directory)linker.c"
          BeforeTargets="BeforeBuildGenerateSources" DependsOnTargets="IncrementalCompileP">

    <Message Importance="high" Text="########## Incremental compile P files @(PIncrementalCompile) ##################" />

    <PropertyGroup>
      <WorkingDirs>@(PIncrementalCompile->'%(RootDir)%(Directory)')</WorkingDirs>
      <WorkingDir>$(WorkingDirs.Split(';')[0])</WorkingDir>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="@(POutputC)" />
      <FileWrites Include="@(POutputH)" />
      <FileWrites Include="@(POutput4ml)" />
    </ItemGroup>

    <Exec Command="$(DropFolder)\Binaries\pc.exe /generate:C0 /shared @(PIncrementalCompile->'%(FullPath)',' ')"  WorkingDirectory="$(WorkingDir)"/>

  </Target>
  
  <Target Name="LinkP" Inputs="@(PLink);" Outputs="%(RootDir)%(Directory)linker.c;%(RootDir)%(Directory)linker.c"
          DependsOnTargets="CompileP" BeforeTargets="BeforeBuildGenerateSources" >
    <PropertyGroup>
      <WorkingDirs>@(PLink->'%(RootDir)%(Directory)')</WorkingDirs>
      <WorkingDir>$(WorkingDirs.Split(';')[0])</WorkingDir>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="$(WorkingDir)linker.c" />
      <FileWrites Include="$(WorkingDir)linker.c" />
    </ItemGroup>
    <!-- must always include linker.c in the final C++ compile -->
    <CreateItem Include="$(WorkingDir)linker.c">
      <Output
          TaskParameter="Include"
          ItemName="ClCompile"/>
    </CreateItem>
    
    <Message Importance="high" Text="########## generating p linker.c  ##################" />
    
    <Exec Command="$(DropFolder)\Binaries\pc.exe /link @(PLink->'%(FullPath)',' ')"  WorkingDirectory="$(WorkingDir)"/>
  </Target>

  <Target Name="CleanCompileP" Condition="'@(PCompile)' != ''" >
    <PropertyGroup>
      <WorkingDirs>@(PCompile->'%(RootDir)%(Directory)')</WorkingDirs>
      <WorkingDir>$(WorkingDirs.Split(';')[0])</WorkingDir>
    </PropertyGroup>
    <Delete Files="@(PCompile->'$(WorkingDir)\%(FileName).c')"/>
    <Delete Files="@(PCompile->'$(WorkingDir)\%(FileName).h')"/>
    <Delete Files="@(PCompile->'$(WorkingDir)\%(FileName).4ml')"/>
    <Delete Files="$(WorkingDir)\linker.c"/>
    <Delete Files="$(WorkingDir)\linker.h"/>
  </Target>

  <Target Name="CopySdkHeaders" Inputs="@(ClInclude)"  Outputs="$(DropFolder)\Headers\%(Filename)" BeforeTargets="PrepareForBuild">
    <CreateItem Include="@(ClInclude)" Condition="'%(ClInclude.CopyToHeaders)'=='True'" >
      <Output TaskParameter="Include" ItemName="SdkHeaders"/>
    </CreateItem>
    <Copy SourceFiles="@(SdkHeaders)" DestinationFolder="$(DropFolder)\Headers" />
  </Target>

  <Target Name="CleanSdkHeaders">
    <CreateItem Include="@(ClInclude)" Condition="'%(ClInclude.CopyToHeaders)'=='True'" >
      <Output TaskParameter="Include" ItemName="SdkHeaders"/>
    </CreateItem>
    <Delete Files="@(SdkHeaders->'$(DropFolder)\Headers\%(Filename)%(Extension)')"/>
  </Target>

  <Target Name="CopyClientFiles" Inputs="@(ClientFile)"  Outputs="$(DropFolder)\ClientFiles\%(Filename)" BeforeTargets="PrepareForBuild">
    <Copy SourceFiles="@(ClientFile)" DestinationFolder="$(DropFolder)\ClientFiles" />
  </Target>

  <Target Name="CleanClientFiles">
    <Delete Files="@(ClientFile->'$(DropFolder)\ClientFiles\%(Filename)%(Extension)')" />
  </Target>
</Project>
